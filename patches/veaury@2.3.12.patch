diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000000000000000000000000000000000000..1f2b05ce103aad1f1a0ed4da279c2396dff22d65
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,3 @@
+{
+  "nuxt.isNuxtApp": false
+}
\ No newline at end of file
diff --git a/types/veaury.d.ts b/types/veaury.d.ts
index 786b7c5a4e9f6ca2dfc7622c6be11e9ba1249bd0..d74db86ae749d280065193b9ecb44f62bfd37e77 100644
--- a/types/veaury.d.ts
+++ b/types/veaury.d.ts
@@ -1,34 +1,34 @@
 // Do not actively import Vue
 // import { Component as VueComponent, VNode } from 'vue'
 
-type ReactNode = object | number | string;
-type VNode = object | number | string;
+type ReactNode = import("react").ReactNode;
+type VNode = import("./vue/runtime-core").VNode;
 type SlotFunction = () => VNode
-type ReactComponent = Function;
-type VueComponent = any;
+type ReactComponent = import("react").FunctionComponent<Record<string, any>>;
+type VueComponent = import('./vue/runtime-core').Component;
 interface propsFromWrapper {
-    [propName: string]: any;
+  [propName: string]: any;
 }
 type component = VueComponent | ReactComponent
 type computedModeReturn = () => propsFromWrapper
 type defaultModeReturn = propsFromWrapper | Function
 type allModeReturn = defaultModeReturn | computedModeReturn
 type injectionFunction<T = allModeReturn> = (props?: propsFromWrapper) => T
-interface injectPropsFromWrapper<T extends allModeReturn = allModeReturn>{
-    (injectionFunction: injectionFunction<T>, component:component): component
+interface injectPropsFromWrapper<T extends allModeReturn = allModeReturn> {
+  (injectionFunction: injectionFunction<T>, component: component): component
 }
 interface magicOptions {
-    [key: string]: any
-    useInjectPropsFromWrapper?: injectionFunction
-    beforeVueAppMount?: (app: object) => any
+  [key: string]: any
+  useInjectPropsFromWrapper?: injectionFunction
+  beforeVueAppMount?: (app: object) => any
 }
 type options = magicOptions | null | undefined;
 interface defineAsyncComponentOptions {
-    [key: string]: any
+  [key: string]: any
 }
 interface ReactMissVueOptions {
-    useVueInjection: injectionFunction
-    beforeVueAppMount?: (app: object) => any
+  useVueInjection: injectionFunction
+  beforeVueAppMount?: (app: object) => any
 }
 type useCrossingHooks = Function
 type CrossingProviderComponent = component
@@ -38,6 +38,7 @@ type CrossingProviderVueInReactReturn = [useCrossingHooks, CrossingProviderCompo
 type useReactMissVueHooks = useCrossingHooks
 type ReactMissVueProvider = CrossingProviderComponent
 type createReactMissVueReturn = [useReactMissVueHooks, ReactMissVueProvider, ReactContext]
+// type InstanceType<T extends abstract new (...args: any) => any> = T extends abstract new (...args: any) => infer R ? R : any;
 
 export const createCrossingProviderForReactInVue: (vueInjection: injectionFunction) => CrossingProviderReactInVueReturn;
 export const createCrossingProviderForVueInReact: (reactInjection: injectionFunction, providerName?: string) => CrossingProviderVueInReactReturn;
@@ -59,15 +60,14 @@ export const createCrossingProviderForPureReactInVue: typeof createCrossingProvi
 export const createCrossingProviderForPureVueInReact: typeof createCrossingProviderForVueInReact;
 export const lazyPureReactInVue: typeof lazyReactInVue;
 export const lazyPureVueInReact: typeof lazyVueInReact;
-
 declare module '@vue/runtime-core' {
-    interface ComponentCustomProperties {
-        __veauryReactRef__?: any;
-    }
+  interface ComponentCustomProperties {
+    __veauryReactRef__?: any;
+  }
 }
 
 declare namespace React {
-    interface Component {
-        __veauryVueRef__?: any;
-    }
+  interface Component {
+    __veauryVueRef__?: any;
+  }
 }
diff --git a/types/vue/reactivity.d.ts b/types/vue/reactivity.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6f95d65653514ea393cf4f9c6aaae98c0a8f8a04
--- /dev/null
+++ b/types/vue/reactivity.d.ts
@@ -0,0 +1,653 @@
+import { IfAny } from './shared';
+
+export declare const enum TrackOpTypes {
+    GET = "get",
+    HAS = "has",
+    ITERATE = "iterate"
+}
+export declare const enum TriggerOpTypes {
+    SET = "set",
+    ADD = "add",
+    DELETE = "delete",
+    CLEAR = "clear"
+}
+
+export declare class EffectScope {
+    detached: boolean;
+    constructor(detached?: boolean);
+    get active(): boolean;
+    run<T>(fn: () => T): T | undefined;
+    stop(fromParent?: boolean): void;
+}
+/**
+ * Creates an effect scope object which can capture the reactive effects (i.e.
+ * computed and watchers) created within it so that these effects can be
+ * disposed together. For detailed use cases of this API, please consult its
+ * corresponding {@link https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md | RFC}.
+ *
+ * @param detached - Can be used to create a "detached" effect scope.
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#effectscope}
+ */
+export declare function effectScope(detached?: boolean): EffectScope;
+/**
+ * Returns the current active effect scope if there is one.
+ *
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#getcurrentscope}
+ */
+export declare function getCurrentScope(): EffectScope | undefined;
+/**
+ * Registers a dispose callback on the current active effect scope. The
+ * callback will be invoked when the associated effect scope is stopped.
+ *
+ * @param fn - The callback function to attach to the scope's cleanup.
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#onscopedispose}
+ */
+export declare function onScopeDispose(fn: () => void): void;
+
+type Dep = Set<ReactiveEffect> & TrackedMarkers;
+/**
+ * wasTracked and newTracked maintain the status for several levels of effect
+ * tracking recursion. One bit per level is used to define whether the dependency
+ * was/is tracked.
+ */
+type TrackedMarkers = {
+    /**
+     * wasTracked
+     */
+    w: number;
+    /**
+     * newTracked
+     */
+    n: number;
+};
+
+export type EffectScheduler = (...args: any[]) => any;
+export type DebuggerEvent = {
+    effect: ReactiveEffect;
+} & DebuggerEventExtraInfo;
+export type DebuggerEventExtraInfo = {
+    target: object;
+    type: TrackOpTypes | TriggerOpTypes;
+    key: any;
+    newValue?: any;
+    oldValue?: any;
+    oldTarget?: Map<any, any> | Set<any>;
+};
+export declare const ITERATE_KEY: unique symbol;
+export declare class ReactiveEffect<T = any> {
+    fn: () => T;
+    scheduler: EffectScheduler | null;
+    active: boolean;
+    deps: Dep[];
+    parent: ReactiveEffect | undefined;
+    onStop?: () => void;
+    onTrack?: (event: DebuggerEvent) => void;
+    onTrigger?: (event: DebuggerEvent) => void;
+    constructor(fn: () => T, scheduler?: EffectScheduler | null, scope?: EffectScope);
+    run(): T | undefined;
+    stop(): void;
+}
+export interface DebuggerOptions {
+    onTrack?: (event: DebuggerEvent) => void;
+    onTrigger?: (event: DebuggerEvent) => void;
+}
+export interface ReactiveEffectOptions extends DebuggerOptions {
+    lazy?: boolean;
+    scheduler?: EffectScheduler;
+    scope?: EffectScope;
+    allowRecurse?: boolean;
+    onStop?: () => void;
+}
+export interface ReactiveEffectRunner<T = any> {
+    (): T;
+    effect: ReactiveEffect;
+}
+/**
+ * Registers the given function to track reactive updates.
+ *
+ * The given function will be run once immediately. Every time any reactive
+ * property that's accessed within it gets updated, the function will run again.
+ *
+ * @param fn - The function that will track reactive updates.
+ * @param options - Allows to control the effect's behaviour.
+ * @returns A runner that can be used to control the effect after creation.
+ */
+export declare function effect<T = any>(fn: () => T, options?: ReactiveEffectOptions): ReactiveEffectRunner;
+/**
+ * Stops the effect associated with the given runner.
+ *
+ * @param runner - Association with the effect to stop tracking.
+ */
+export declare function stop(runner: ReactiveEffectRunner): void;
+/**
+ * Temporarily pauses tracking.
+ */
+export declare function pauseTracking(): void;
+/**
+ * Re-enables effect tracking (if it was paused).
+ */
+export declare function enableTracking(): void;
+/**
+ * Resets the previous global effect tracking state.
+ */
+export declare function resetTracking(): void;
+/**
+ * Tracks access to a reactive property.
+ *
+ * This will check which effect is running at the moment and record it as dep
+ * which records all effects that depend on the reactive property.
+ *
+ * @param target - Object holding the reactive property.
+ * @param type - Defines the type of access to the reactive property.
+ * @param key - Identifier of the reactive property to track.
+ */
+export declare function track(target: object, type: TrackOpTypes, key: unknown): void;
+/**
+ * Finds all deps associated with the target (or a specific property) and
+ * triggers the effects stored within.
+ *
+ * @param target - The reactive object.
+ * @param type - Defines the type of the operation that needs to trigger effects.
+ * @param key - Can be used to target a specific reactive property in the target object.
+ */
+export declare function trigger(target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map<unknown, unknown> | Set<unknown>): void;
+
+export declare const enum ReactiveFlags {
+    SKIP = "__v_skip",
+    IS_REACTIVE = "__v_isReactive",
+    IS_READONLY = "__v_isReadonly",
+    IS_SHALLOW = "__v_isShallow",
+    RAW = "__v_raw"
+}
+export type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>;
+/**
+ * Returns a reactive proxy of the object.
+ *
+ * The reactive conversion is "deep": it affects all nested properties. A
+ * reactive object also deeply unwraps any properties that are refs while
+ * maintaining reactivity.
+ *
+ * @example
+ * ```js
+ * const obj = reactive({ count: 0 })
+ * ```
+ *
+ * @param target - The source object.
+ * @see {@link https://vuejs.org/api/reactivity-core.html#reactive}
+ */
+export declare function reactive<T extends object>(target: T): UnwrapNestedRefs<T>;
+declare const ShallowReactiveMarker: unique symbol;
+export type ShallowReactive<T> = T & {
+    [ShallowReactiveMarker]?: true;
+};
+/**
+ * Shallow version of {@link reactive()}.
+ *
+ * Unlike {@link reactive()}, there is no deep conversion: only root-level
+ * properties are reactive for a shallow reactive object. Property values are
+ * stored and exposed as-is - this also means properties with ref values will
+ * not be automatically unwrapped.
+ *
+ * @example
+ * ```js
+ * const state = shallowReactive({
+ *   foo: 1,
+ *   nested: {
+ *     bar: 2
+ *   }
+ * })
+ *
+ * // mutating state's own properties is reactive
+ * state.foo++
+ *
+ * // ...but does not convert nested objects
+ * isReactive(state.nested) // false
+ *
+ * // NOT reactive
+ * state.nested.bar++
+ * ```
+ *
+ * @param target - The source object.
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreactive}
+ */
+export declare function shallowReactive<T extends object>(target: T): ShallowReactive<T>;
+type Primitive = string | number | boolean | bigint | symbol | undefined | null;
+type Builtin = Primitive | Function | Date | Error | RegExp;
+export type DeepReadonly<T> = T extends Builtin ? T : T extends Map<infer K, infer V> ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>> : T extends ReadonlyMap<infer K, infer V> ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>> : T extends WeakMap<infer K, infer V> ? WeakMap<DeepReadonly<K>, DeepReadonly<V>> : T extends Set<infer U> ? ReadonlySet<DeepReadonly<U>> : T extends ReadonlySet<infer U> ? ReadonlySet<DeepReadonly<U>> : T extends WeakSet<infer U> ? WeakSet<DeepReadonly<U>> : T extends Promise<infer U> ? Promise<DeepReadonly<U>> : T extends Ref<infer U> ? Readonly<Ref<DeepReadonly<U>>> : T extends {} ? {
+    readonly [K in keyof T]: DeepReadonly<T[K]>;
+} : Readonly<T>;
+/**
+ * Takes an object (reactive or plain) or a ref and returns a readonly proxy to
+ * the original.
+ *
+ * A readonly proxy is deep: any nested property accessed will be readonly as
+ * well. It also has the same ref-unwrapping behavior as {@link reactive()},
+ * except the unwrapped values will also be made readonly.
+ *
+ * @example
+ * ```js
+ * const original = reactive({ count: 0 })
+ *
+ * const copy = readonly(original)
+ *
+ * watchEffect(() => {
+ *   // works for reactivity tracking
+ *   console.log(copy.count)
+ * })
+ *
+ * // mutating original will trigger watchers relying on the copy
+ * original.count++
+ *
+ * // mutating the copy will fail and result in a warning
+ * copy.count++ // warning!
+ * ```
+ *
+ * @param target - The source object.
+ * @see {@link https://vuejs.org/api/reactivity-core.html#readonly}
+ */
+export declare function readonly<T extends object>(target: T): DeepReadonly<UnwrapNestedRefs<T>>;
+/**
+ * Shallow version of {@link readonly()}.
+ *
+ * Unlike {@link readonly()}, there is no deep conversion: only root-level
+ * properties are made readonly. Property values are stored and exposed as-is -
+ * this also means properties with ref values will not be automatically
+ * unwrapped.
+ *
+ * @example
+ * ```js
+ * const state = shallowReadonly({
+ *   foo: 1,
+ *   nested: {
+ *     bar: 2
+ *   }
+ * })
+ *
+ * // mutating state's own properties will fail
+ * state.foo++
+ *
+ * // ...but works on nested objects
+ * isReadonly(state.nested) // false
+ *
+ * // works
+ * state.nested.bar++
+ * ```
+ *
+ * @param target - The source object.
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreadonly}
+ */
+export declare function shallowReadonly<T extends object>(target: T): Readonly<T>;
+/**
+ * Checks if an object is a proxy created by {@link reactive()} or
+ * {@link shallowReactive()} (or {@link ref()} in some cases).
+ *
+ * @example
+ * ```js
+ * isReactive(reactive({}))            // => true
+ * isReactive(readonly(reactive({})))  // => true
+ * isReactive(ref({}).value)           // => true
+ * isReactive(readonly(ref({})).value) // => true
+ * isReactive(ref(true))               // => false
+ * isReactive(shallowRef({}).value)    // => false
+ * isReactive(shallowReactive({}))     // => true
+ * ```
+ *
+ * @param value - The value to check.
+ * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreactive}
+ */
+export declare function isReactive(value: unknown): boolean;
+/**
+ * Checks whether the passed value is a readonly object. The properties of a
+ * readonly object can change, but they can't be assigned directly via the
+ * passed object.
+ *
+ * The proxies created by {@link readonly()} and {@link shallowReadonly()} are
+ * both considered readonly, as is a computed ref without a set function.
+ *
+ * @param value - The value to check.
+ * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreadonly}
+ */
+export declare function isReadonly(value: unknown): boolean;
+export declare function isShallow(value: unknown): boolean;
+/**
+ * Checks if an object is a proxy created by {@link reactive},
+ * {@link readonly}, {@link shallowReactive} or {@link shallowReadonly()}.
+ *
+ * @param value - The value to check.
+ * @see {@link https://vuejs.org/api/reactivity-utilities.html#isproxy}
+ */
+export declare function isProxy(value: unknown): boolean;
+/**
+ * Returns the raw, original object of a Vue-created proxy.
+ *
+ * `toRaw()` can return the original object from proxies created by
+ * {@link reactive()}, {@link readonly()}, {@link shallowReactive()} or
+ * {@link shallowReadonly()}.
+ *
+ * This is an escape hatch that can be used to temporarily read without
+ * incurring proxy access / tracking overhead or write without triggering
+ * changes. It is **not** recommended to hold a persistent reference to the
+ * original object. Use with caution.
+ *
+ * @example
+ * ```js
+ * const foo = {}
+ * const reactiveFoo = reactive(foo)
+ *
+ * console.log(toRaw(reactiveFoo) === foo) // true
+ * ```
+ *
+ * @param observed - The object for which the "raw" value is requested.
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#toraw}
+ */
+export declare function toRaw<T>(observed: T): T;
+export type Raw<T> = T & {
+    [RawSymbol]?: true;
+};
+/**
+ * Marks an object so that it will never be converted to a proxy. Returns the
+ * object itself.
+ *
+ * @example
+ * ```js
+ * const foo = markRaw({})
+ * console.log(isReactive(reactive(foo))) // false
+ *
+ * // also works when nested inside other reactive objects
+ * const bar = reactive({ foo })
+ * console.log(isReactive(bar.foo)) // false
+ * ```
+ *
+ * **Warning:** `markRaw()` together with the shallow APIs such as
+ * {@link shallowReactive()} allow you to selectively opt-out of the default
+ * deep reactive/readonly conversion and embed raw, non-proxied objects in your
+ * state graph.
+ *
+ * @param value - The object to be marked as "raw".
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#markraw}
+ */
+export declare function markRaw<T extends object>(value: T): Raw<T>;
+
+declare const ComputedRefSymbol: unique symbol;
+export interface ComputedRef<T = any> extends WritableComputedRef<T> {
+    readonly value: T;
+    [ComputedRefSymbol]: true;
+}
+export interface WritableComputedRef<T> extends Ref<T> {
+    readonly effect: ReactiveEffect<T>;
+}
+export type ComputedGetter<T> = (...args: any[]) => T;
+export type ComputedSetter<T> = (v: T) => void;
+export interface WritableComputedOptions<T> {
+    get: ComputedGetter<T>;
+    set: ComputedSetter<T>;
+}
+/**
+ * Takes a getter function and returns a readonly reactive ref object for the
+ * returned value from the getter. It can also take an object with get and set
+ * functions to create a writable ref object.
+ *
+ * @example
+ * ```js
+ * // Creating a readonly computed ref:
+ * const count = ref(1)
+ * const plusOne = computed(() => count.value + 1)
+ *
+ * console.log(plusOne.value) // 2
+ * plusOne.value++ // error
+ * ```
+ *
+ * ```js
+ * // Creating a writable computed ref:
+ * const count = ref(1)
+ * const plusOne = computed({
+ *   get: () => count.value + 1,
+ *   set: (val) => {
+ *     count.value = val - 1
+ *   }
+ * })
+ *
+ * plusOne.value = 1
+ * console.log(count.value) // 0
+ * ```
+ *
+ * @param getter - Function that produces the next value.
+ * @param debugOptions - For debugging. See {@link https://vuejs.org/guide/extras/reactivity-in-depth.html#computed-debugging}.
+ * @see {@link https://vuejs.org/api/reactivity-core.html#computed}
+ */
+export declare function computed<T>(getter: ComputedGetter<T>, debugOptions?: DebuggerOptions): ComputedRef<T>;
+export declare function computed<T>(options: WritableComputedOptions<T>, debugOptions?: DebuggerOptions): WritableComputedRef<T>;
+
+type CollectionTypes = IterableCollections | WeakCollections;
+type IterableCollections = Map<any, any> | Set<any>;
+type WeakCollections = WeakMap<any, any> | WeakSet<any>;
+
+declare const RefSymbol: unique symbol;
+declare const RawSymbol: unique symbol;
+export interface Ref<T = any> {
+    value: T;
+    /**
+     * Type differentiator only.
+     * We need this to be in public d.ts but don't want it to show up in IDE
+     * autocomplete, so we use a private Symbol instead.
+     */
+    [RefSymbol]: true;
+}
+/**
+ * Checks if a value is a ref object.
+ *
+ * @param r - The value to inspect.
+ * @see {@link https://vuejs.org/api/reactivity-utilities.html#isref}
+ */
+export declare function isRef<T>(r: Ref<T> | unknown): r is Ref<T>;
+/**
+ * Takes an inner value and returns a reactive and mutable ref object, which
+ * has a single property `.value` that points to the inner value.
+ *
+ * @param value - The object to wrap in the ref.
+ * @see {@link https://vuejs.org/api/reactivity-core.html#ref}
+ */
+export declare function ref<T extends Ref>(value: T): T;
+export declare function ref<T>(value: T): Ref<UnwrapRef<T>>;
+export declare function ref<T = any>(): Ref<T | undefined>;
+declare const ShallowRefMarker: unique symbol;
+export type ShallowRef<T = any> = Ref<T> & {
+    [ShallowRefMarker]?: true;
+};
+/**
+ * Shallow version of {@link ref()}.
+ *
+ * @example
+ * ```js
+ * const state = shallowRef({ count: 1 })
+ *
+ * // does NOT trigger change
+ * state.value.count = 2
+ *
+ * // does trigger change
+ * state.value = { count: 2 }
+ * ```
+ *
+ * @param value - The "inner value" for the shallow ref.
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowref}
+ */
+export declare function shallowRef<T>(value: MaybeRef<T>): Ref<T> | ShallowRef<T>;
+export declare function shallowRef<T extends Ref>(value: T): T;
+export declare function shallowRef<T>(value: T): ShallowRef<T>;
+export declare function shallowRef<T = any>(): ShallowRef<T | undefined>;
+/**
+ * Force trigger effects that depends on a shallow ref. This is typically used
+ * after making deep mutations to the inner value of a shallow ref.
+ *
+ * @example
+ * ```js
+ * const shallow = shallowRef({
+ *   greet: 'Hello, world'
+ * })
+ *
+ * // Logs "Hello, world" once for the first run-through
+ * watchEffect(() => {
+ *   console.log(shallow.value.greet)
+ * })
+ *
+ * // This won't trigger the effect because the ref is shallow
+ * shallow.value.greet = 'Hello, universe'
+ *
+ * // Logs "Hello, universe"
+ * triggerRef(shallow)
+ * ```
+ *
+ * @param ref - The ref whose tied effects shall be executed.
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#triggerref}
+ */
+export declare function triggerRef(ref: Ref): void;
+export type MaybeRef<T = any> = T | Ref<T>;
+export type MaybeRefOrGetter<T = any> = MaybeRef<T> | (() => T);
+/**
+ * Returns the inner value if the argument is a ref, otherwise return the
+ * argument itself. This is a sugar function for
+ * `val = isRef(val) ? val.value : val`.
+ *
+ * @example
+ * ```js
+ * function useFoo(x: number | Ref<number>) {
+ *   const unwrapped = unref(x)
+ *   // unwrapped is guaranteed to be number now
+ * }
+ * ```
+ *
+ * @param ref - Ref or plain value to be converted into the plain value.
+ * @see {@link https://vuejs.org/api/reactivity-utilities.html#unref}
+ */
+export declare function unref<T>(ref: MaybeRef<T> | ComputedRef<T>): T;
+/**
+ * Normalizes values / refs / getters to values.
+ * This is similar to {@link unref()}, except that it also normalizes getters.
+ * If the argument is a getter, it will be invoked and its return value will
+ * be returned.
+ *
+ * @example
+ * ```js
+ * toValue(1) // 1
+ * toValue(ref(1)) // 1
+ * toValue(() => 1) // 1
+ * ```
+ *
+ * @param source - A getter, an existing ref, or a non-function value.
+ * @see {@link https://vuejs.org/api/reactivity-utilities.html#tovalue}
+ */
+export declare function toValue<T>(source: MaybeRefOrGetter<T> | ComputedRef<T>): T;
+/**
+ * Returns a reactive proxy for the given object.
+ *
+ * If the object already is reactive, it's returned as-is. If not, a new
+ * reactive proxy is created. Direct child properties that are refs are properly
+ * handled, as well.
+ *
+ * @param objectWithRefs - Either an already-reactive object or a simple object
+ * that contains refs.
+ */
+export declare function proxyRefs<T extends object>(objectWithRefs: T): ShallowUnwrapRef<T>;
+export type CustomRefFactory<T> = (track: () => void, trigger: () => void) => {
+    get: () => T;
+    set: (value: T) => void;
+};
+/**
+ * Creates a customized ref with explicit control over its dependency tracking
+ * and updates triggering.
+ *
+ * @param factory - The function that receives the `track` and `trigger` callbacks.
+ * @see {@link https://vuejs.org/api/reactivity-advanced.html#customref}
+ */
+export declare function customRef<T>(factory: CustomRefFactory<T>): Ref<T>;
+export type ToRefs<T = any> = {
+    [K in keyof T]: ToRef<T[K]>;
+};
+/**
+ * Converts a reactive object to a plain object where each property of the
+ * resulting object is a ref pointing to the corresponding property of the
+ * original object. Each individual ref is created using {@link toRef()}.
+ *
+ * @param object - Reactive object to be made into an object of linked refs.
+ * @see {@link https://vuejs.org/api/reactivity-utilities.html#torefs}
+ */
+export declare function toRefs<T extends object>(object: T): ToRefs<T>;
+export type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>;
+/**
+ * Used to normalize values / refs / getters into refs.
+ *
+ * @example
+ * ```js
+ * // returns existing refs as-is
+ * toRef(existingRef)
+ *
+ * // creates a ref that calls the getter on .value access
+ * toRef(() => props.foo)
+ *
+ * // creates normal refs from non-function values
+ * // equivalent to ref(1)
+ * toRef(1)
+ * ```
+ *
+ * Can also be used to create a ref for a property on a source reactive object.
+ * The created ref is synced with its source property: mutating the source
+ * property will update the ref, and vice-versa.
+ *
+ * @example
+ * ```js
+ * const state = reactive({
+ *   foo: 1,
+ *   bar: 2
+ * })
+ *
+ * const fooRef = toRef(state, 'foo')
+ *
+ * // mutating the ref updates the original
+ * fooRef.value++
+ * console.log(state.foo) // 2
+ *
+ * // mutating the original also updates the ref
+ * state.foo++
+ * console.log(fooRef.value) // 3
+ * ```
+ *
+ * @param source - A getter, an existing ref, a non-function value, or a
+ *                 reactive object to create a property ref from.
+ * @param [key] - (optional) Name of the property in the reactive object.
+ * @see {@link https://vuejs.org/api/reactivity-utilities.html#toref}
+ */
+export declare function toRef<T>(value: T): T extends () => infer R ? Readonly<Ref<R>> : T extends Ref ? T : Ref<UnwrapRef<T>>;
+export declare function toRef<T extends object, K extends keyof T>(object: T, key: K): ToRef<T[K]>;
+export declare function toRef<T extends object, K extends keyof T>(object: T, key: K, defaultValue: T[K]): ToRef<Exclude<T[K], undefined>>;
+type BaseTypes = string | number | boolean;
+/**
+ * This is a special exported interface for other packages to declare
+ * additional types that should bail out for ref unwrapping. For example
+ * \@vue/runtime-dom can declare it like so in its d.ts:
+ *
+ * ``` ts
+ * declare module '@vue/reactivity' {
+ *   export interface RefUnwrapBailTypes {
+ *     runtimeDOMBailTypes: Node | Window
+ *   }
+ * }
+ * ```
+ */
+export interface RefUnwrapBailTypes {
+}
+export type ShallowUnwrapRef<T> = {
+    [K in keyof T]: T[K] extends Ref<infer V> ? V : T[K] extends Ref<infer V> | undefined ? unknown extends V ? undefined : V | undefined : T[K];
+};
+export type UnwrapRef<T> = T extends ShallowRef<infer V> ? V : T extends Ref<infer V> ? UnwrapRefSimple<V> : UnwrapRefSimple<T>;
+type UnwrapRefSimple<T> = T extends Function | CollectionTypes | BaseTypes | Ref | RefUnwrapBailTypes[keyof RefUnwrapBailTypes] | {
+    [RawSymbol]?: true;
+} ? T : T extends ReadonlyArray<any> ? {
+    [K in keyof T]: UnwrapRefSimple<T[K]>;
+} : T extends object & {
+    [ShallowReactiveMarker]?: never;
+} ? {
+    [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>;
+} : T;
+
+export declare function deferredComputed<T>(getter: () => T): ComputedRef<T>;
+
diff --git a/types/vue/runtime-core.d.ts b/types/vue/runtime-core.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f212a3299dc3b5d619c30704bd557d1485cecc83
--- /dev/null
+++ b/types/vue/runtime-core.d.ts
@@ -0,0 +1,1634 @@
+import { computed as computed$1, ShallowUnwrapRef, UnwrapNestedRefs, DebuggerEvent, ComputedGetter, WritableComputedOptions, Ref, ReactiveEffect, ComputedRef, DebuggerOptions, reactive } from './reactivity';
+export { ComputedGetter, ComputedRef, ComputedSetter, CustomRefFactory, DebuggerEvent, DebuggerEventExtraInfo, DebuggerOptions, DeepReadonly, EffectScheduler, EffectScope, MaybeRef, MaybeRefOrGetter, Raw, ReactiveEffect, ReactiveEffectOptions, ReactiveEffectRunner, ReactiveFlags, Ref, ShallowReactive, ShallowRef, ShallowUnwrapRef, ToRef, ToRefs, TrackOpTypes, TriggerOpTypes, UnwrapNestedRefs, UnwrapRef, WritableComputedOptions, WritableComputedRef, customRef, effect, effectScope, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, triggerRef, unref } from './reactivity';
+import { IfAny, Prettify, Awaited, UnionToIntersection, LooseRequired } from './shared';
+export { camelize, capitalize, normalizeClass, normalizeProps, normalizeStyle, toDisplayString, toHandlerKey } from './shared';
+
+export declare const computed: typeof computed$1;
+
+export type Slot<T extends any = any> = (...args: IfAny<T, any[], [T] | (T extends undefined ? [] : never)>) => VNode[];
+type InternalSlots = {
+    [name: string]: Slot | undefined;
+};
+export type Slots = Readonly<InternalSlots>;
+declare const SlotSymbol: unique symbol;
+export type SlotsType<T extends Record<string, any> = Record<string, any>> = {
+    [SlotSymbol]?: T;
+};
+type StrictUnwrapSlotsType<S extends SlotsType, T = NonNullable<S[typeof SlotSymbol]>> = [keyof S] extends [never] ? Slots : Readonly<T>;
+type UnwrapSlotsType<S extends SlotsType, T = NonNullable<S[typeof SlotSymbol]>> = [keyof S] extends [never] ? Slots : Readonly<Prettify<{
+    [K in keyof T]: NonNullable<T[K]> extends (...args: any[]) => any ? T[K] : Slot<T[K]>;
+}>>;
+type RawSlots = {
+    [name: string]: unknown;
+    $stable?: boolean;
+};
+
+interface SchedulerJob extends Function {
+    id?: number;
+    pre?: boolean;
+    active?: boolean;
+    computed?: boolean;
+    /**
+     * Indicates whether the effect is allowed to recursively trigger itself
+     * when managed by the scheduler.
+     *
+     * By default, a job cannot trigger itself because some built-in method calls,
+     * e.g. Array.prototype.push actually performs reads as well (#1740) which
+     * can lead to confusing infinite loops.
+     * The allowed cases are component update functions and watch callbacks.
+     * Component update functions may update child component props, which in turn
+     * trigger flush: "pre" watch callbacks that mutates state that the parent
+     * relies on (#1801). Watch callbacks doesn't track its dependencies so if it
+     * triggers itself again, it's likely intentional and it is the user's
+     * responsibility to perform recursive state mutation that eventually
+     * stabilizes (#1727).
+     */
+    allowRecurse?: boolean;
+    /**
+     * Attached by renderer.ts when setting up a component's render effect
+     * Used to obtain component information when reporting max recursive updates.
+     * dev only.
+     */
+    ownerInstance?: ComponentInternalInstance;
+}
+type SchedulerJobs = SchedulerJob | SchedulerJob[];
+export declare function nextTick<T = void, R = void>(this: T, fn?: (this: T) => R): Promise<Awaited<R>>;
+export declare function queuePostFlushCb(cb: SchedulerJobs): void;
+
+export type ObjectEmitsOptions = Record<string, ((...args: any[]) => any) | null>;
+export type EmitsOptions = ObjectEmitsOptions | string[];
+type EmitsToProps<T extends EmitsOptions> = T extends string[] ? {
+    [K in string & `on${Capitalize<T[number]>}`]?: (...args: any[]) => any;
+} : T extends ObjectEmitsOptions ? {
+    [K in string & `on${Capitalize<string & keyof T>}`]?: K extends `on${infer C}` ? T[Uncapitalize<C>] extends null ? (...args: any[]) => any : (...args: T[Uncapitalize<C>] extends (...args: infer P) => any ? P : never) => any : never;
+} : {};
+type EmitFn<Options = ObjectEmitsOptions, Event extends keyof Options = keyof Options> = Options extends Array<infer V> ? (event: V, ...args: any[]) => void : {} extends Options ? (event: string, ...args: any[]) => void : UnionToIntersection<{
+    [key in Event]: Options[key] extends (...args: infer Args) => any ? (event: key, ...args: Args) => void : (event: key, ...args: any[]) => void;
+}[Event]>;
+
+/**
+ * Custom properties added to component instances in any way and can be accessed through `this`
+ *
+ * @example
+ * Here is an example of adding a property `$router` to every component instance:
+ * ```ts
+ * import { createApp } from 'vue'
+ * import { Router, createRouter } from 'vue-router'
+ *
+ * declare module '@vue/runtime-core' {
+ *   interface ComponentCustomProperties {
+ *     $router: Router
+ *   }
+ * }
+ *
+ * // effectively adding the router to every component instance
+ * const app = createApp({})
+ * const router = createRouter()
+ * app.config.globalProperties.$router = router
+ *
+ * const vm = app.mount('#app')
+ * // we can access the router from the instance
+ * vm.$router.push('/')
+ * ```
+ */
+export interface ComponentCustomProperties {
+}
+type IsDefaultMixinComponent<T> = T extends ComponentOptionsMixin ? ComponentOptionsMixin extends T ? true : false : false;
+type MixinToOptionTypes<T> = T extends ComponentOptionsBase<infer P, infer B, infer D, infer C, infer M, infer Mixin, infer Extends, any, any, infer Defaults, any, any, any> ? OptionTypesType<P & {}, B & {}, D & {}, C & {}, M & {}, Defaults & {}> & IntersectionMixin<Mixin> & IntersectionMixin<Extends> : never;
+type ExtractMixin<T> = {
+    Mixin: MixinToOptionTypes<T>;
+}[T extends ComponentOptionsMixin ? 'Mixin' : never];
+type IntersectionMixin<T> = IsDefaultMixinComponent<T> extends true ? OptionTypesType : UnionToIntersection<ExtractMixin<T>>;
+type UnwrapMixinsType<T, Type extends OptionTypesKeys> = T extends OptionTypesType ? T[Type] : never;
+type EnsureNonVoid<T> = T extends void ? {} : T;
+type ComponentPublicInstanceConstructor<T extends ComponentPublicInstance<Props, RawBindings, D, C, M> = ComponentPublicInstance<any>, Props = any, RawBindings = any, D = any, C extends ComputedOptions = ComputedOptions, M extends MethodOptions = MethodOptions> = {
+    __isFragment?: never;
+    __isTeleport?: never;
+    __isSuspense?: never;
+    new (...args: any[]): T;
+};
+export type CreateComponentPublicInstance<P = {}, B = {}, D = {}, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = {}, PublicProps = P, Defaults = {}, MakeDefaultsOptional extends boolean = false, I extends ComponentInjectOptions = {}, S extends SlotsType = {}, PublicMixin = IntersectionMixin<Mixin> & IntersectionMixin<Extends>, PublicP = UnwrapMixinsType<PublicMixin, 'P'> & EnsureNonVoid<P>, PublicB = UnwrapMixinsType<PublicMixin, 'B'> & EnsureNonVoid<B>, PublicD = UnwrapMixinsType<PublicMixin, 'D'> & EnsureNonVoid<D>, PublicC extends ComputedOptions = UnwrapMixinsType<PublicMixin, 'C'> & EnsureNonVoid<C>, PublicM extends MethodOptions = UnwrapMixinsType<PublicMixin, 'M'> & EnsureNonVoid<M>, PublicDefaults = UnwrapMixinsType<PublicMixin, 'Defaults'> & EnsureNonVoid<Defaults>> = ComponentPublicInstance<PublicP, PublicB, PublicD, PublicC, PublicM, E, PublicProps, PublicDefaults, MakeDefaultsOptional, ComponentOptionsBase<P, B, D, C, M, Mixin, Extends, E, string, Defaults, {}, string, S>, I, S>;
+export type ComponentPublicInstance<P = {}, // props type extracted from props option
+B = {}, // raw bindings returned from setup()
+D = {}, // return from data()
+C extends ComputedOptions = {}, M extends MethodOptions = {}, E extends EmitsOptions = {}, PublicProps = P, Defaults = {}, MakeDefaultsOptional extends boolean = false, Options = ComponentOptionsBase<any, any, any, any, any, any, any, any, any>, I extends ComponentInjectOptions = {}, S extends SlotsType = {}> = {
+    $: ComponentInternalInstance;
+    $data: D;
+    $props: MakeDefaultsOptional extends true ? Partial<Defaults> & Omit<Prettify<P> & PublicProps, keyof Defaults> : Prettify<P> & PublicProps;
+    $attrs: Data;
+    $refs: Data;
+    $slots: UnwrapSlotsType<S>;
+    $root: ComponentPublicInstance | null;
+    $parent: ComponentPublicInstance | null;
+    $emit: EmitFn<E>;
+    $el: any;
+    $options: Options & MergedComponentOptionsOverride;
+    $forceUpdate: () => void;
+    $nextTick: typeof nextTick;
+    $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (...args: [R, R]) => any : (...args: any) => any, options?: WatchOptions): WatchStopHandle;
+} & IfAny<P, P, Omit<P, keyof ShallowUnwrapRef<B>>> & ShallowUnwrapRef<B> & UnwrapNestedRefs<D> & ExtractComputedReturns<C> & M & ComponentCustomProperties & InjectToObject<I>;
+
+declare const enum LifecycleHooks {
+    BEFORE_CREATE = "bc",
+    CREATED = "c",
+    BEFORE_MOUNT = "bm",
+    MOUNTED = "m",
+    BEFORE_UPDATE = "bu",
+    UPDATED = "u",
+    BEFORE_UNMOUNT = "bum",
+    UNMOUNTED = "um",
+    DEACTIVATED = "da",
+    ACTIVATED = "a",
+    RENDER_TRIGGERED = "rtg",
+    RENDER_TRACKED = "rtc",
+    ERROR_CAPTURED = "ec",
+    SERVER_PREFETCH = "sp"
+}
+
+export interface SuspenseProps {
+    onResolve?: () => void;
+    onPending?: () => void;
+    onFallback?: () => void;
+    timeout?: string | number;
+    /**
+     * Allow suspense to be captured by parent suspense
+     *
+     * @default false
+     */
+    suspensible?: boolean;
+}
+declare const SuspenseImpl: {
+    name: string;
+    __isSuspense: boolean;
+    process(n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean, rendererInternals: RendererInternals): void;
+    hydrate: typeof hydrateSuspense;
+    create: typeof createSuspenseBoundary;
+    normalize: typeof normalizeSuspenseChildren;
+};
+export declare const Suspense: {
+    new (): {
+        $props: VNodeProps & SuspenseProps;
+        $slots: {
+            default(): VNode[];
+            fallback(): VNode[];
+        };
+    };
+    __isSuspense: true;
+};
+export interface SuspenseBoundary {
+    vnode: VNode<RendererNode, RendererElement, SuspenseProps>;
+    parent: SuspenseBoundary | null;
+    parentComponent: ComponentInternalInstance | null;
+    isSVG: boolean;
+    container: RendererElement;
+    hiddenContainer: RendererElement;
+    anchor: RendererNode | null;
+    activeBranch: VNode | null;
+    pendingBranch: VNode | null;
+    deps: number;
+    pendingId: number;
+    timeout: number;
+    isInFallback: boolean;
+    isHydrating: boolean;
+    isUnmounted: boolean;
+    effects: Function[];
+    resolve(force?: boolean, sync?: boolean): void;
+    fallback(fallbackVNode: VNode): void;
+    move(container: RendererElement, anchor: RendererNode | null, type: MoveType): void;
+    next(): RendererNode | null;
+    registerDep(instance: ComponentInternalInstance, setupRenderEffect: SetupRenderEffectFn): void;
+    unmount(parentSuspense: SuspenseBoundary | null, doRemove?: boolean): void;
+}
+declare function createSuspenseBoundary(vnode: VNode, parentSuspense: SuspenseBoundary | null, parentComponent: ComponentInternalInstance | null, container: RendererElement, hiddenContainer: RendererElement, anchor: RendererNode | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean, rendererInternals: RendererInternals, isHydrating?: boolean): SuspenseBoundary;
+declare function hydrateSuspense(node: Node, vnode: VNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean, rendererInternals: RendererInternals, hydrateNode: (node: Node, vnode: VNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, slotScopeIds: string[] | null, optimized: boolean) => Node | null): Node | null;
+declare function normalizeSuspenseChildren(vnode: VNode): void;
+
+export type RootHydrateFunction = (vnode: VNode<Node, Element>, container: (Element | ShadowRoot) & {
+    _vnode?: VNode;
+}) => void;
+
+type Hook<T = () => void> = T | T[];
+export interface BaseTransitionProps<HostElement = RendererElement> {
+    mode?: 'in-out' | 'out-in' | 'default';
+    appear?: boolean;
+    persisted?: boolean;
+    onBeforeEnter?: Hook<(el: HostElement) => void>;
+    onEnter?: Hook<(el: HostElement, done: () => void) => void>;
+    onAfterEnter?: Hook<(el: HostElement) => void>;
+    onEnterCancelled?: Hook<(el: HostElement) => void>;
+    onBeforeLeave?: Hook<(el: HostElement) => void>;
+    onLeave?: Hook<(el: HostElement, done: () => void) => void>;
+    onAfterLeave?: Hook<(el: HostElement) => void>;
+    onLeaveCancelled?: Hook<(el: HostElement) => void>;
+    onBeforeAppear?: Hook<(el: HostElement) => void>;
+    onAppear?: Hook<(el: HostElement, done: () => void) => void>;
+    onAfterAppear?: Hook<(el: HostElement) => void>;
+    onAppearCancelled?: Hook<(el: HostElement) => void>;
+}
+export interface TransitionHooks<HostElement = RendererElement> {
+    mode: BaseTransitionProps['mode'];
+    persisted: boolean;
+    beforeEnter(el: HostElement): void;
+    enter(el: HostElement): void;
+    leave(el: HostElement, remove: () => void): void;
+    clone(vnode: VNode): TransitionHooks<HostElement>;
+    afterLeave?(): void;
+    delayLeave?(el: HostElement, earlyRemove: () => void, delayedLeave: () => void): void;
+    delayedLeave?(): void;
+}
+export interface TransitionState {
+    isMounted: boolean;
+    isLeaving: boolean;
+    isUnmounting: boolean;
+    leavingVNodes: Map<any, Record<string, VNode>>;
+}
+export declare function useTransitionState(): TransitionState;
+export declare const BaseTransitionPropsValidators: {
+    mode: StringConstructor;
+    appear: BooleanConstructor;
+    persisted: BooleanConstructor;
+    onBeforeEnter: (ArrayConstructor | FunctionConstructor)[];
+    onEnter: (ArrayConstructor | FunctionConstructor)[];
+    onAfterEnter: (ArrayConstructor | FunctionConstructor)[];
+    onEnterCancelled: (ArrayConstructor | FunctionConstructor)[];
+    onBeforeLeave: (ArrayConstructor | FunctionConstructor)[];
+    onLeave: (ArrayConstructor | FunctionConstructor)[];
+    onAfterLeave: (ArrayConstructor | FunctionConstructor)[];
+    onLeaveCancelled: (ArrayConstructor | FunctionConstructor)[];
+    onBeforeAppear: (ArrayConstructor | FunctionConstructor)[];
+    onAppear: (ArrayConstructor | FunctionConstructor)[];
+    onAfterAppear: (ArrayConstructor | FunctionConstructor)[];
+    onAppearCancelled: (ArrayConstructor | FunctionConstructor)[];
+};
+export declare const BaseTransition: new () => {
+    $props: BaseTransitionProps<any>;
+    $slots: {
+        default(): VNode[];
+    };
+};
+export declare function resolveTransitionHooks(vnode: VNode, props: BaseTransitionProps<any>, state: TransitionState, instance: ComponentInternalInstance): TransitionHooks;
+export declare function setTransitionHooks(vnode: VNode, hooks: TransitionHooks): void;
+export declare function getTransitionRawChildren(children: VNode[], keepComment?: boolean, parentKey?: VNode['key']): VNode[];
+
+export interface Renderer<HostElement = RendererElement> {
+    render: RootRenderFunction<HostElement>;
+    createApp: CreateAppFunction<HostElement>;
+}
+export interface HydrationRenderer extends Renderer<Element | ShadowRoot> {
+    hydrate: RootHydrateFunction;
+}
+export type RootRenderFunction<HostElement = RendererElement> = (vnode: VNode | null, container: HostElement, isSVG?: boolean) => void;
+export interface RendererOptions<HostNode = RendererNode, HostElement = RendererElement> {
+    patchProp(el: HostElement, key: string, prevValue: any, nextValue: any, isSVG?: boolean, prevChildren?: VNode<HostNode, HostElement>[], parentComponent?: ComponentInternalInstance | null, parentSuspense?: SuspenseBoundary | null, unmountChildren?: UnmountChildrenFn): void;
+    insert(el: HostNode, parent: HostElement, anchor?: HostNode | null): void;
+    remove(el: HostNode): void;
+    createElement(type: string, isSVG?: boolean, isCustomizedBuiltIn?: string, vnodeProps?: (VNodeProps & {
+        [key: string]: any;
+    }) | null): HostElement;
+    createText(text: string): HostNode;
+    createComment(text: string): HostNode;
+    setText(node: HostNode, text: string): void;
+    setElementText(node: HostElement, text: string): void;
+    parentNode(node: HostNode): HostElement | null;
+    nextSibling(node: HostNode): HostNode | null;
+    querySelector?(selector: string): HostElement | null;
+    setScopeId?(el: HostElement, id: string): void;
+    cloneNode?(node: HostNode): HostNode;
+    insertStaticContent?(content: string, parent: HostElement, anchor: HostNode | null, isSVG: boolean, start?: HostNode | null, end?: HostNode | null): [HostNode, HostNode];
+}
+export interface RendererNode {
+    [key: string]: any;
+}
+export interface RendererElement extends RendererNode {
+}
+interface RendererInternals<HostNode = RendererNode, HostElement = RendererElement> {
+    p: PatchFn;
+    um: UnmountFn;
+    r: RemoveFn;
+    m: MoveFn;
+    mt: MountComponentFn;
+    mc: MountChildrenFn;
+    pc: PatchChildrenFn;
+    pbc: PatchBlockChildrenFn;
+    n: NextFn;
+    o: RendererOptions<HostNode, HostElement>;
+}
+type PatchFn = (n1: VNode | null, // null means this is a mount
+n2: VNode, container: RendererElement, anchor?: RendererNode | null, parentComponent?: ComponentInternalInstance | null, parentSuspense?: SuspenseBoundary | null, isSVG?: boolean, slotScopeIds?: string[] | null, optimized?: boolean) => void;
+type MountChildrenFn = (children: VNodeArrayChildren, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean, start?: number) => void;
+type PatchChildrenFn = (n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean) => void;
+type PatchBlockChildrenFn = (oldChildren: VNode[], newChildren: VNode[], fallbackContainer: RendererElement, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null) => void;
+type MoveFn = (vnode: VNode, container: RendererElement, anchor: RendererNode | null, type: MoveType, parentSuspense?: SuspenseBoundary | null) => void;
+type NextFn = (vnode: VNode) => RendererNode | null;
+type UnmountFn = (vnode: VNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, doRemove?: boolean, optimized?: boolean) => void;
+type RemoveFn = (vnode: VNode) => void;
+type UnmountChildrenFn = (children: VNode[], parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, doRemove?: boolean, optimized?: boolean, start?: number) => void;
+type MountComponentFn = (initialVNode: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean) => void;
+type SetupRenderEffectFn = (instance: ComponentInternalInstance, initialVNode: VNode, container: RendererElement, anchor: RendererNode | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean) => void;
+declare const enum MoveType {
+    ENTER = 0,
+    LEAVE = 1,
+    REORDER = 2
+}
+/**
+ * The createRenderer function accepts two generic arguments:
+ * HostNode and HostElement, corresponding to Node and Element types in the
+ * host environment. For example, for runtime-dom, HostNode would be the DOM
+ * `Node` interface and HostElement would be the DOM `Element` interface.
+ *
+ * Custom renderers can pass in the platform specific types like this:
+ *
+ * ``` js
+ * const { render, createApp } = createRenderer<Node, Element>({
+ *   patchProp,
+ *   ...nodeOps
+ * })
+ * ```
+ */
+export declare function createRenderer<HostNode = RendererNode, HostElement = RendererElement>(options: RendererOptions<HostNode, HostElement>): Renderer<HostElement>;
+export declare function createHydrationRenderer(options: RendererOptions<Node, Element>): HydrationRenderer;
+
+type MatchPattern = string | RegExp | (string | RegExp)[];
+export interface KeepAliveProps {
+    include?: MatchPattern;
+    exclude?: MatchPattern;
+    max?: number | string;
+}
+export declare const KeepAlive: {
+    new (): {
+        $props: VNodeProps & KeepAliveProps;
+        $slots: {
+            default(): VNode[];
+        };
+    };
+    __isKeepAlive: true;
+};
+export declare function onActivated(hook: Function, target?: ComponentInternalInstance | null): void;
+export declare function onDeactivated(hook: Function, target?: ComponentInternalInstance | null): void;
+
+export declare const onBeforeMount: (hook: () => any, target?: ComponentInternalInstance | null) => false | Function | undefined;
+export declare const onMounted: (hook: () => any, target?: ComponentInternalInstance | null) => false | Function | undefined;
+export declare const onBeforeUpdate: (hook: () => any, target?: ComponentInternalInstance | null) => false | Function | undefined;
+export declare const onUpdated: (hook: () => any, target?: ComponentInternalInstance | null) => false | Function | undefined;
+export declare const onBeforeUnmount: (hook: () => any, target?: ComponentInternalInstance | null) => false | Function | undefined;
+export declare const onUnmounted: (hook: () => any, target?: ComponentInternalInstance | null) => false | Function | undefined;
+export declare const onServerPrefetch: (hook: () => any, target?: ComponentInternalInstance | null) => false | Function | undefined;
+type DebuggerHook = (e: DebuggerEvent) => void;
+export declare const onRenderTriggered: (hook: DebuggerHook, target?: ComponentInternalInstance | null) => false | Function | undefined;
+export declare const onRenderTracked: (hook: DebuggerHook, target?: ComponentInternalInstance | null) => false | Function | undefined;
+type ErrorCapturedHook<TError = unknown> = (err: TError, instance: ComponentPublicInstance | null, info: string) => boolean | void;
+export declare function onErrorCaptured<TError = Error>(hook: ErrorCapturedHook<TError>, target?: ComponentInternalInstance | null): void;
+
+export type ComponentPropsOptions<P = Data> = ComponentObjectPropsOptions<P> | string[];
+export type ComponentObjectPropsOptions<P = Data> = {
+    [K in keyof P]: Prop<P[K]> | null;
+};
+export type Prop<T, D = T> = PropOptions<T, D> | PropType<T>;
+type DefaultFactory<T> = (props: Data) => T | null | undefined;
+interface PropOptions<T = any, D = T> {
+    type?: PropType<T> | true | null;
+    required?: boolean;
+    default?: D | DefaultFactory<D> | null | undefined | object;
+    validator?(value: unknown): boolean;
+}
+export type PropType<T> = PropConstructor<T> | PropConstructor<T>[];
+type PropConstructor<T = any> = {
+    new (...args: any[]): T & {};
+} | {
+    (): T;
+} | PropMethod<T>;
+type PropMethod<T, TConstructor = any> = [T] extends [
+    ((...args: any) => any) | undefined
+] ? {
+    new (): TConstructor;
+    (): T;
+    readonly prototype: TConstructor;
+} : never;
+type RequiredKeys<T> = {
+    [K in keyof T]: T[K] extends {
+        required: true;
+    } | {
+        default: any;
+    } | BooleanConstructor | {
+        type: BooleanConstructor;
+    } ? T[K] extends {
+        default: undefined | (() => undefined);
+    } ? never : K : never;
+}[keyof T];
+type OptionalKeys<T> = Exclude<keyof T, RequiredKeys<T>>;
+type DefaultKeys<T> = {
+    [K in keyof T]: T[K] extends {
+        default: any;
+    } | BooleanConstructor | {
+        type: BooleanConstructor;
+    } ? T[K] extends {
+        type: BooleanConstructor;
+        required: true;
+    } ? never : K : never;
+}[keyof T];
+type InferPropType<T> = [T] extends [null] ? any : [T] extends [{
+    type: null | true;
+}] ? any : [T] extends [ObjectConstructor | {
+    type: ObjectConstructor;
+}] ? Record<string, any> : [T] extends [BooleanConstructor | {
+    type: BooleanConstructor;
+}] ? boolean : [T] extends [DateConstructor | {
+    type: DateConstructor;
+}] ? Date : [T] extends [(infer U)[] | {
+    type: (infer U)[];
+}] ? U extends DateConstructor ? Date | InferPropType<U> : InferPropType<U> : [T] extends [Prop<infer V, infer D>] ? unknown extends V ? IfAny<V, V, D> : V : T;
+/**
+ * Extract prop types from a runtime props options object.
+ * The extracted types are **internal** - i.e. the resolved props received by
+ * the component.
+ * - Boolean props are always present
+ * - Props with default values are always present
+ *
+ * To extract accepted props from the parent, use {@link ExtractPublicPropTypes}.
+ */
+export type ExtractPropTypes<O> = {
+    [K in keyof Pick<O, RequiredKeys<O>>]: InferPropType<O[K]>;
+} & {
+    [K in keyof Pick<O, OptionalKeys<O>>]?: InferPropType<O[K]>;
+};
+type PublicRequiredKeys<T> = {
+    [K in keyof T]: T[K] extends {
+        required: true;
+    } ? K : never;
+}[keyof T];
+type PublicOptionalKeys<T> = Exclude<keyof T, PublicRequiredKeys<T>>;
+/**
+ * Extract prop types from a runtime props options object.
+ * The extracted types are **public** - i.e. the expected props that can be
+ * passed to component.
+ */
+export type ExtractPublicPropTypes<O> = {
+    [K in keyof Pick<O, PublicRequiredKeys<O>>]: InferPropType<O[K]>;
+} & {
+    [K in keyof Pick<O, PublicOptionalKeys<O>>]?: InferPropType<O[K]>;
+};
+export type ExtractDefaultPropTypes<O> = O extends object ? {
+    [K in keyof Pick<O, DefaultKeys<O>>]: InferPropType<O[K]>;
+} : {};
+
+/**
+Runtime helper for applying directives to a vnode. Example usage:
+
+const comp = resolveComponent('comp')
+const foo = resolveDirective('foo')
+const bar = resolveDirective('bar')
+
+return withDirectives(h(comp), [
+  [foo, this.x],
+  [bar, this.y]
+])
+*/
+
+export interface DirectiveBinding<V = any> {
+    instance: ComponentPublicInstance | null;
+    value: V;
+    oldValue: V | null;
+    arg?: string;
+    modifiers: DirectiveModifiers;
+    dir: ObjectDirective<any, V>;
+}
+export type DirectiveHook<T = any, Prev = VNode<any, T> | null, V = any> = (el: T, binding: DirectiveBinding<V>, vnode: VNode<any, T>, prevVNode: Prev) => void;
+type SSRDirectiveHook = (binding: DirectiveBinding, vnode: VNode) => Data | undefined;
+export interface ObjectDirective<T = any, V = any> {
+    created?: DirectiveHook<T, null, V>;
+    beforeMount?: DirectiveHook<T, null, V>;
+    mounted?: DirectiveHook<T, null, V>;
+    beforeUpdate?: DirectiveHook<T, VNode<any, T>, V>;
+    updated?: DirectiveHook<T, VNode<any, T>, V>;
+    beforeUnmount?: DirectiveHook<T, null, V>;
+    unmounted?: DirectiveHook<T, null, V>;
+    getSSRProps?: SSRDirectiveHook;
+    deep?: boolean;
+}
+export type FunctionDirective<T = any, V = any> = DirectiveHook<T, any, V>;
+export type Directive<T = any, V = any> = ObjectDirective<T, V> | FunctionDirective<T, V>;
+type DirectiveModifiers = Record<string, boolean>;
+export type DirectiveArguments = Array<[Directive | undefined] | [Directive | undefined, any] | [Directive | undefined, any, string] | [Directive | undefined, any, string, DirectiveModifiers]>;
+/**
+ * Adds directives to a VNode.
+ */
+export declare function withDirectives<T extends VNode>(vnode: T, directives: DirectiveArguments): T;
+
+export declare const enum DeprecationTypes {
+    GLOBAL_MOUNT = "GLOBAL_MOUNT",
+    GLOBAL_MOUNT_CONTAINER = "GLOBAL_MOUNT_CONTAINER",
+    GLOBAL_EXTEND = "GLOBAL_EXTEND",
+    GLOBAL_PROTOTYPE = "GLOBAL_PROTOTYPE",
+    GLOBAL_SET = "GLOBAL_SET",
+    GLOBAL_DELETE = "GLOBAL_DELETE",
+    GLOBAL_OBSERVABLE = "GLOBAL_OBSERVABLE",
+    GLOBAL_PRIVATE_UTIL = "GLOBAL_PRIVATE_UTIL",
+    CONFIG_SILENT = "CONFIG_SILENT",
+    CONFIG_DEVTOOLS = "CONFIG_DEVTOOLS",
+    CONFIG_KEY_CODES = "CONFIG_KEY_CODES",
+    CONFIG_PRODUCTION_TIP = "CONFIG_PRODUCTION_TIP",
+    CONFIG_IGNORED_ELEMENTS = "CONFIG_IGNORED_ELEMENTS",
+    CONFIG_WHITESPACE = "CONFIG_WHITESPACE",
+    CONFIG_OPTION_MERGE_STRATS = "CONFIG_OPTION_MERGE_STRATS",
+    INSTANCE_SET = "INSTANCE_SET",
+    INSTANCE_DELETE = "INSTANCE_DELETE",
+    INSTANCE_DESTROY = "INSTANCE_DESTROY",
+    INSTANCE_EVENT_EMITTER = "INSTANCE_EVENT_EMITTER",
+    INSTANCE_EVENT_HOOKS = "INSTANCE_EVENT_HOOKS",
+    INSTANCE_CHILDREN = "INSTANCE_CHILDREN",
+    INSTANCE_LISTENERS = "INSTANCE_LISTENERS",
+    INSTANCE_SCOPED_SLOTS = "INSTANCE_SCOPED_SLOTS",
+    INSTANCE_ATTRS_CLASS_STYLE = "INSTANCE_ATTRS_CLASS_STYLE",
+    OPTIONS_DATA_FN = "OPTIONS_DATA_FN",
+    OPTIONS_DATA_MERGE = "OPTIONS_DATA_MERGE",
+    OPTIONS_BEFORE_DESTROY = "OPTIONS_BEFORE_DESTROY",
+    OPTIONS_DESTROYED = "OPTIONS_DESTROYED",
+    WATCH_ARRAY = "WATCH_ARRAY",
+    PROPS_DEFAULT_THIS = "PROPS_DEFAULT_THIS",
+    V_ON_KEYCODE_MODIFIER = "V_ON_KEYCODE_MODIFIER",
+    CUSTOM_DIR = "CUSTOM_DIR",
+    ATTR_FALSE_VALUE = "ATTR_FALSE_VALUE",
+    ATTR_ENUMERATED_COERCION = "ATTR_ENUMERATED_COERCION",
+    TRANSITION_CLASSES = "TRANSITION_CLASSES",
+    TRANSITION_GROUP_ROOT = "TRANSITION_GROUP_ROOT",
+    COMPONENT_ASYNC = "COMPONENT_ASYNC",
+    COMPONENT_FUNCTIONAL = "COMPONENT_FUNCTIONAL",
+    COMPONENT_V_MODEL = "COMPONENT_V_MODEL",
+    RENDER_FUNCTION = "RENDER_FUNCTION",
+    FILTERS = "FILTERS",
+    PRIVATE_APIS = "PRIVATE_APIS"
+}
+type CompatConfig = Partial<Record<DeprecationTypes, boolean | 'suppress-warning'>> & {
+    MODE?: 2 | 3 | ((comp: Component | null) => 2 | 3);
+};
+declare function configureCompat(config: CompatConfig): void;
+
+/**
+ * Interface for declaring custom options.
+ *
+ * @example
+ * ```ts
+ * declare module '@vue/runtime-core' {
+ *   interface ComponentCustomOptions {
+ *     beforeRouteUpdate?(
+ *       to: Route,
+ *       from: Route,
+ *       next: () => void
+ *     ): void
+ *   }
+ * }
+ * ```
+ */
+export interface ComponentCustomOptions {
+}
+export type RenderFunction = () => VNodeChild;
+export interface ComponentOptionsBase<Props, RawBindings, D, C extends ComputedOptions, M extends MethodOptions, Mixin extends ComponentOptionsMixin, Extends extends ComponentOptionsMixin, E extends EmitsOptions, EE extends string = string, Defaults = {}, I extends ComponentInjectOptions = {}, II extends string = string, S extends SlotsType = {}> extends LegacyOptions<Props, D, C, M, Mixin, Extends, I, II>, ComponentInternalOptions, ComponentCustomOptions {
+    setup?: (this: void, props: LooseRequired<Props & Prettify<UnwrapMixinsType<IntersectionMixin<Mixin> & IntersectionMixin<Extends>, 'P'>>>, ctx: SetupContext<E, S>) => Promise<RawBindings> | RawBindings | RenderFunction | void;
+    name?: string;
+    template?: string | object;
+    render?: Function;
+    components?: Record<string, Component>;
+    directives?: Record<string, Directive>;
+    inheritAttrs?: boolean;
+    emits?: (E | EE[]) & ThisType<void>;
+    slots?: S;
+    expose?: string[];
+    serverPrefetch?(): void | Promise<any>;
+    compilerOptions?: RuntimeCompilerOptions;
+    call?: (this: unknown, ...args: unknown[]) => never;
+    __isFragment?: never;
+    __isTeleport?: never;
+    __isSuspense?: never;
+    __defaults?: Defaults;
+}
+/**
+ * Subset of compiler options that makes sense for the runtime.
+ */
+export interface RuntimeCompilerOptions {
+    isCustomElement?: (tag: string) => boolean;
+    whitespace?: 'preserve' | 'condense';
+    comments?: boolean;
+    delimiters?: [string, string];
+}
+export type ComponentOptionsWithoutProps<Props = {}, RawBindings = {}, D = {}, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = EmitsOptions, EE extends string = string, I extends ComponentInjectOptions = {}, II extends string = string, S extends SlotsType = {}, PE = Props & EmitsToProps<E>> = ComponentOptionsBase<PE, RawBindings, D, C, M, Mixin, Extends, E, EE, {}, I, II, S> & {
+    props?: undefined;
+} & ThisType<CreateComponentPublicInstance<PE, RawBindings, D, C, M, Mixin, Extends, E, PE, {}, false, I, S>>;
+export type ComponentOptionsWithArrayProps<PropNames extends string = string, RawBindings = {}, D = {}, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = EmitsOptions, EE extends string = string, I extends ComponentInjectOptions = {}, II extends string = string, S extends SlotsType = {}, Props = Prettify<Readonly<{
+    [key in PropNames]?: any;
+} & EmitsToProps<E>>>> = ComponentOptionsBase<Props, RawBindings, D, C, M, Mixin, Extends, E, EE, {}, I, II, S> & {
+    props: PropNames[];
+} & ThisType<CreateComponentPublicInstance<Props, RawBindings, D, C, M, Mixin, Extends, E, Props, {}, false, I, S>>;
+export type ComponentOptionsWithObjectProps<PropsOptions = ComponentObjectPropsOptions, RawBindings = {}, D = {}, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = EmitsOptions, EE extends string = string, I extends ComponentInjectOptions = {}, II extends string = string, S extends SlotsType = {}, Props = Prettify<Readonly<ExtractPropTypes<PropsOptions> & EmitsToProps<E>>>, Defaults = ExtractDefaultPropTypes<PropsOptions>> = ComponentOptionsBase<Props, RawBindings, D, C, M, Mixin, Extends, E, EE, Defaults, I, II, S> & {
+    props: PropsOptions & ThisType<void>;
+} & ThisType<CreateComponentPublicInstance<Props, RawBindings, D, C, M, Mixin, Extends, E, Props, Defaults, false, I, S>>;
+export type ComponentOptions<Props = {}, RawBindings = any, D = any, C extends ComputedOptions = any, M extends MethodOptions = any, Mixin extends ComponentOptionsMixin = any, Extends extends ComponentOptionsMixin = any, E extends EmitsOptions = any, S extends SlotsType = any> = ComponentOptionsBase<Props, RawBindings, D, C, M, Mixin, Extends, E, string, S> & ThisType<CreateComponentPublicInstance<{}, RawBindings, D, C, M, Mixin, Extends, E, Readonly<Props>>>;
+export type ComponentOptionsMixin = ComponentOptionsBase<any, any, any, any, any, any, any, any, any, any, any>;
+export type ComputedOptions = Record<string, ComputedGetter<any> | WritableComputedOptions<any>>;
+export interface MethodOptions {
+    [key: string]: Function;
+}
+type ExtractComputedReturns<T extends any> = {
+    [key in keyof T]: T[key] extends {
+        get: (...args: any[]) => infer TReturn;
+    } ? TReturn : T[key] extends (...args: any[]) => infer TReturn ? TReturn : never;
+};
+type ObjectWatchOptionItem = {
+    handler: WatchCallback | string;
+} & WatchOptions;
+type WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem;
+type ComponentWatchOptionItem = WatchOptionItem | WatchOptionItem[];
+type ComponentWatchOptions = Record<string, ComponentWatchOptionItem>;
+export type ComponentProvideOptions = ObjectProvideOptions | Function;
+type ObjectProvideOptions = Record<string | symbol, unknown>;
+export type ComponentInjectOptions = string[] | ObjectInjectOptions;
+type ObjectInjectOptions = Record<string | symbol, string | symbol | {
+    from?: string | symbol;
+    default?: unknown;
+}>;
+type InjectToObject<T extends ComponentInjectOptions> = T extends string[] ? {
+    [K in T[number]]?: unknown;
+} : T extends ObjectInjectOptions ? {
+    [K in keyof T]?: unknown;
+} : never;
+interface LegacyOptions<Props, D, C extends ComputedOptions, M extends MethodOptions, Mixin extends ComponentOptionsMixin, Extends extends ComponentOptionsMixin, I extends ComponentInjectOptions, II extends string> {
+    compatConfig?: CompatConfig;
+    [key: string]: any;
+    data?: (this: CreateComponentPublicInstance<Props, {}, {}, {}, MethodOptions, Mixin, Extends>, vm: CreateComponentPublicInstance<Props, {}, {}, {}, MethodOptions, Mixin, Extends>) => D;
+    computed?: C;
+    methods?: M;
+    watch?: ComponentWatchOptions;
+    provide?: ComponentProvideOptions;
+    inject?: I | II[];
+    filters?: Record<string, Function>;
+    mixins?: Mixin[];
+    extends?: Extends;
+    beforeCreate?(): void;
+    created?(): void;
+    beforeMount?(): void;
+    mounted?(): void;
+    beforeUpdate?(): void;
+    updated?(): void;
+    activated?(): void;
+    deactivated?(): void;
+    /** @deprecated use `beforeUnmount` instead */
+    beforeDestroy?(): void;
+    beforeUnmount?(): void;
+    /** @deprecated use `unmounted` instead */
+    destroyed?(): void;
+    unmounted?(): void;
+    renderTracked?: DebuggerHook;
+    renderTriggered?: DebuggerHook;
+    errorCaptured?: ErrorCapturedHook;
+    /**
+     * runtime compile only
+     * @deprecated use `compilerOptions.delimiters` instead.
+     */
+    delimiters?: [string, string];
+    /**
+     * #3468
+     *
+     * type-only, used to assist Mixin's type inference,
+     * typescript will try to simplify the inferred `Mixin` type,
+     * with the `__differentiator`, typescript won't be able to combine different mixins,
+     * because the `__differentiator` will be different
+     */
+    __differentiator?: keyof D | keyof C | keyof M;
+}
+type MergedHook<T = () => void> = T | T[];
+type MergedComponentOptionsOverride = {
+    beforeCreate?: MergedHook;
+    created?: MergedHook;
+    beforeMount?: MergedHook;
+    mounted?: MergedHook;
+    beforeUpdate?: MergedHook;
+    updated?: MergedHook;
+    activated?: MergedHook;
+    deactivated?: MergedHook;
+    /** @deprecated use `beforeUnmount` instead */
+    beforeDestroy?: MergedHook;
+    beforeUnmount?: MergedHook;
+    /** @deprecated use `unmounted` instead */
+    destroyed?: MergedHook;
+    unmounted?: MergedHook;
+    renderTracked?: MergedHook<DebuggerHook>;
+    renderTriggered?: MergedHook<DebuggerHook>;
+    errorCaptured?: MergedHook<ErrorCapturedHook>;
+};
+type OptionTypesKeys = 'P' | 'B' | 'D' | 'C' | 'M' | 'Defaults';
+type OptionTypesType<P = {}, B = {}, D = {}, C extends ComputedOptions = {}, M extends MethodOptions = {}, Defaults = {}> = {
+    P: P;
+    B: B;
+    D: D;
+    C: C;
+    M: M;
+    Defaults: Defaults;
+};
+
+export interface InjectionKey<T> extends Symbol {
+}
+export declare function provide<T, K = InjectionKey<T> | string | number>(key: K, value: K extends InjectionKey<infer V> ? V : T): void;
+export declare function inject<T>(key: InjectionKey<T> | string): T | undefined;
+export declare function inject<T>(key: InjectionKey<T> | string, defaultValue: T, treatDefaultAsFactory?: false): T;
+export declare function inject<T>(key: InjectionKey<T> | string, defaultValue: T | (() => T), treatDefaultAsFactory: true): T;
+/**
+ * Returns true if `inject()` can be used without warning about being called in the wrong place (e.g. outside of
+ * setup()). This is used by libraries that want to use `inject()` internally without triggering a warning to the end
+ * user. One example is `useRoute()` in `vue-router`.
+ */
+export declare function hasInjectionContext(): boolean;
+
+type PublicProps = VNodeProps & AllowedComponentProps & ComponentCustomProps;
+type ResolveProps<PropsOrPropOptions, E extends EmitsOptions> = Readonly<PropsOrPropOptions extends ComponentPropsOptions ? ExtractPropTypes<PropsOrPropOptions> : PropsOrPropOptions> & ({} extends E ? {} : EmitsToProps<E>);
+export type DefineComponent<PropsOrPropOptions = {}, RawBindings = {}, D = {}, C extends ComputedOptions = ComputedOptions, M extends MethodOptions = MethodOptions, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = {}, EE extends string = string, PP = PublicProps, Props = ResolveProps<PropsOrPropOptions, E>, Defaults = ExtractDefaultPropTypes<PropsOrPropOptions>, S extends SlotsType = {}> = ComponentPublicInstanceConstructor<CreateComponentPublicInstance<Props, RawBindings, D, C, M, Mixin, Extends, E, PP & Props, Defaults, true, {}, S>> & ComponentOptionsBase<Props, RawBindings, D, C, M, Mixin, Extends, E, EE, Defaults, {}, string, S> & PP;
+export declare function defineComponent<Props extends Record<string, any>, E extends EmitsOptions = {}, EE extends string = string, S extends SlotsType = {}>(setup: (props: Props, ctx: SetupContext<E, S>) => RenderFunction | Promise<RenderFunction>, options?: Pick<ComponentOptions, 'name' | 'inheritAttrs'> & {
+    props?: (keyof Props)[];
+    emits?: E | EE[];
+    slots?: S;
+}): (props: Props & EmitsToProps<E>) => any;
+export declare function defineComponent<Props extends Record<string, any>, E extends EmitsOptions = {}, EE extends string = string, S extends SlotsType = {}>(setup: (props: Props, ctx: SetupContext<E, S>) => RenderFunction | Promise<RenderFunction>, options?: Pick<ComponentOptions, 'name' | 'inheritAttrs'> & {
+    props?: ComponentObjectPropsOptions<Props>;
+    emits?: E | EE[];
+    slots?: S;
+}): (props: Props & EmitsToProps<E>) => any;
+export declare function defineComponent<Props = {}, RawBindings = {}, D = {}, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = {}, EE extends string = string, S extends SlotsType = {}, I extends ComponentInjectOptions = {}, II extends string = string>(options: ComponentOptionsWithoutProps<Props, RawBindings, D, C, M, Mixin, Extends, E, EE, I, II, S>): DefineComponent<Props, RawBindings, D, C, M, Mixin, Extends, E, EE, PublicProps, ResolveProps<Props, E>, ExtractDefaultPropTypes<Props>, S>;
+export declare function defineComponent<PropNames extends string, RawBindings, D, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = {}, EE extends string = string, S extends SlotsType = {}, I extends ComponentInjectOptions = {}, II extends string = string, Props = Readonly<{
+    [key in PropNames]?: any;
+}>>(options: ComponentOptionsWithArrayProps<PropNames, RawBindings, D, C, M, Mixin, Extends, E, EE, I, II, S>): DefineComponent<Props, RawBindings, D, C, M, Mixin, Extends, E, EE, PublicProps, ResolveProps<Props, E>, ExtractDefaultPropTypes<Props>, S>;
+export declare function defineComponent<PropsOptions extends Readonly<ComponentPropsOptions>, RawBindings, D, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin, E extends EmitsOptions = {}, EE extends string = string, S extends SlotsType = {}, I extends ComponentInjectOptions = {}, II extends string = string>(options: ComponentOptionsWithObjectProps<PropsOptions, RawBindings, D, C, M, Mixin, Extends, E, EE, I, II, S>): DefineComponent<PropsOptions, RawBindings, D, C, M, Mixin, Extends, E, EE, PublicProps, ResolveProps<PropsOptions, E>, ExtractDefaultPropTypes<PropsOptions>, S>;
+
+export interface App<HostElement = any> {
+    version: string;
+    config: AppConfig;
+    use<Options extends unknown[]>(plugin: Plugin<Options>, ...options: Options): this;
+    use<Options>(plugin: Plugin<Options>, options: Options): this;
+    mixin(mixin: ComponentOptions): this;
+    component(name: string): Component | undefined;
+    component(name: string, component: Component | DefineComponent): this;
+    directive(name: string): Directive | undefined;
+    directive(name: string, directive: Directive): this;
+    mount(rootContainer: HostElement | string, isHydrate?: boolean, isSVG?: boolean): ComponentPublicInstance;
+    unmount(): void;
+    provide<T>(key: InjectionKey<T> | string, value: T): this;
+    /**
+     * Runs a function with the app as active instance. This allows using of `inject()` within the function to get access
+     * to variables provided via `app.provide()`.
+     *
+     * @param fn - function to run with the app as active instance
+     */
+    runWithContext<T>(fn: () => T): T;
+    _uid: number;
+    _component: ConcreteComponent;
+    _props: Data | null;
+    _container: HostElement | null;
+    _context: AppContext;
+    _instance: ComponentInternalInstance | null;
+    /**
+     * v2 compat only
+     */
+    filter?(name: string): Function | undefined;
+    filter?(name: string, filter: Function): this;
+}
+export type OptionMergeFunction = (to: unknown, from: unknown) => any;
+export interface AppConfig {
+    readonly isNativeTag?: (tag: string) => boolean;
+    performance: boolean;
+    optionMergeStrategies: Record<string, OptionMergeFunction>;
+    globalProperties: ComponentCustomProperties & Record<string, any>;
+    errorHandler?: (err: unknown, instance: ComponentPublicInstance | null, info: string) => void;
+    warnHandler?: (msg: string, instance: ComponentPublicInstance | null, trace: string) => void;
+    /**
+     * Options to pass to `@vue/compiler-dom`.
+     * Only supported in runtime compiler build.
+     */
+    compilerOptions: RuntimeCompilerOptions;
+    /**
+     * @deprecated use config.compilerOptions.isCustomElement
+     */
+    isCustomElement?: (tag: string) => boolean;
+    /**
+     * Temporary config for opt-in to unwrap injected refs.
+     * @deprecated this no longer has effect. 3.3 always unwraps injected refs.
+     */
+    unwrapInjectedRef?: boolean;
+}
+export interface AppContext {
+    app: App;
+    config: AppConfig;
+    mixins: ComponentOptions[];
+    components: Record<string, Component>;
+    directives: Record<string, Directive>;
+    provides: Record<string | symbol, any>;
+}
+type PluginInstallFunction<Options> = Options extends unknown[] ? (app: App, ...options: Options) => any : (app: App, options: Options) => any;
+export type Plugin<Options = any[]> = (PluginInstallFunction<Options> & {
+    install?: PluginInstallFunction<Options>;
+}) | {
+    install: PluginInstallFunction<Options>;
+};
+export type CreateAppFunction<HostElement> = (rootComponent: Component, rootProps?: Data | null) => App<HostElement>;
+
+type TeleportVNode = VNode<RendererNode, RendererElement, TeleportProps>;
+export interface TeleportProps {
+    to: string | RendererElement | null | undefined;
+    disabled?: boolean;
+}
+declare const TeleportImpl: {
+    name: string;
+    __isTeleport: boolean;
+    process(n1: TeleportVNode | null, n2: TeleportVNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean, internals: RendererInternals): void;
+    remove(vnode: VNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, optimized: boolean, { um: unmount, o: { remove: hostRemove } }: RendererInternals, doRemove: boolean): void;
+    move: typeof moveTeleport;
+    hydrate: typeof hydrateTeleport;
+};
+declare const enum TeleportMoveTypes {
+    TARGET_CHANGE = 0,
+    TOGGLE = 1,
+    REORDER = 2
+}
+declare function moveTeleport(vnode: VNode, container: RendererElement, parentAnchor: RendererNode | null, { o: { insert }, m: move }: RendererInternals, moveType?: TeleportMoveTypes): void;
+declare function hydrateTeleport(node: Node, vnode: TeleportVNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, slotScopeIds: string[] | null, optimized: boolean, { o: { nextSibling, parentNode, querySelector } }: RendererInternals<Node, Element>, hydrateChildren: (node: Node | null, vnode: VNode, container: Element, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, slotScopeIds: string[] | null, optimized: boolean) => Node | null): Node | null;
+export declare const Teleport: {
+    new (): {
+        $props: VNodeProps & TeleportProps;
+        $slots: {
+            default(): VNode[];
+        };
+    };
+    __isTeleport: true;
+};
+
+/**
+ * @private
+ */
+export declare function resolveComponent(name: string, maybeSelfReference?: boolean): ConcreteComponent | string;
+declare const NULL_DYNAMIC_COMPONENT: unique symbol;
+/**
+ * @private
+ */
+export declare function resolveDynamicComponent(component: unknown): VNodeTypes;
+/**
+ * @private
+ */
+export declare function resolveDirective(name: string): Directive | undefined;
+
+export declare const Fragment: {
+    new (): {
+        $props: VNodeProps;
+    };
+    __isFragment: true;
+};
+export declare const Text: unique symbol;
+export declare const Comment: unique symbol;
+export declare const Static: unique symbol;
+export type VNodeTypes = string | VNode | Component | typeof Text | typeof Static | typeof Comment | typeof Fragment | typeof Teleport | typeof TeleportImpl | typeof Suspense | typeof SuspenseImpl;
+export type VNodeRef = string | Ref | ((ref: Element | ComponentPublicInstance | null, refs: Record<string, any>) => void);
+type VNodeNormalizedRefAtom = {
+    i: ComponentInternalInstance;
+    r: VNodeRef;
+    k?: string;
+    f?: boolean;
+};
+type VNodeNormalizedRef = VNodeNormalizedRefAtom | VNodeNormalizedRefAtom[];
+type VNodeMountHook = (vnode: VNode) => void;
+type VNodeUpdateHook = (vnode: VNode, oldVNode: VNode) => void;
+export type VNodeProps = {
+    key?: string | number | symbol;
+    ref?: VNodeRef;
+    ref_for?: boolean;
+    ref_key?: string;
+    onVnodeBeforeMount?: VNodeMountHook | VNodeMountHook[];
+    onVnodeMounted?: VNodeMountHook | VNodeMountHook[];
+    onVnodeBeforeUpdate?: VNodeUpdateHook | VNodeUpdateHook[];
+    onVnodeUpdated?: VNodeUpdateHook | VNodeUpdateHook[];
+    onVnodeBeforeUnmount?: VNodeMountHook | VNodeMountHook[];
+    onVnodeUnmounted?: VNodeMountHook | VNodeMountHook[];
+};
+type VNodeChildAtom = VNode | string | number | boolean | null | undefined | void;
+export type VNodeArrayChildren = Array<VNodeArrayChildren | VNodeChildAtom>;
+export type VNodeChild = VNodeChildAtom | VNodeArrayChildren;
+export type VNodeNormalizedChildren = string | VNodeArrayChildren | RawSlots | null;
+export interface VNode<HostNode = RendererNode, HostElement = RendererElement, ExtraProps = {
+    [key: string]: any;
+}> {
+    type: VNodeTypes;
+    props: (VNodeProps & ExtraProps) | null;
+    key: string | number | symbol | null;
+    ref: VNodeNormalizedRef | null;
+    /**
+     * SFC only. This is assigned on vnode creation using currentScopeId
+     * which is set alongside currentRenderingInstance.
+     */
+    scopeId: string | null;
+    children: VNodeNormalizedChildren;
+    component: ComponentInternalInstance | null;
+    dirs: DirectiveBinding[] | null;
+    transition: TransitionHooks<HostElement> | null;
+    el: HostNode | null;
+    anchor: HostNode | null;
+    target: HostElement | null;
+    targetAnchor: HostNode | null;
+    suspense: SuspenseBoundary | null;
+    shapeFlag: number;
+    patchFlag: number;
+    appContext: AppContext | null;
+}
+/**
+ * Open a block.
+ * This must be called before `createBlock`. It cannot be part of `createBlock`
+ * because the children of the block are evaluated before `createBlock` itself
+ * is called. The generated code typically looks like this:
+ *
+ * ```js
+ * function render() {
+ *   return (openBlock(),createBlock('div', null, [...]))
+ * }
+ * ```
+ * disableTracking is true when creating a v-for fragment block, since a v-for
+ * fragment always diffs its children.
+ *
+ * @private
+ */
+export declare function openBlock(disableTracking?: boolean): void;
+/**
+ * Block tracking sometimes needs to be disabled, for example during the
+ * creation of a tree that needs to be cached by v-once. The compiler generates
+ * code like this:
+ *
+ * ``` js
+ * _cache[1] || (
+ *   setBlockTracking(-1),
+ *   _cache[1] = createVNode(...),
+ *   setBlockTracking(1),
+ *   _cache[1]
+ * )
+ * ```
+ *
+ * @private
+ */
+export declare function setBlockTracking(value: number): void;
+/**
+ * @private
+ */
+export declare function createElementBlock(type: string | typeof Fragment, props?: Record<string, any> | null, children?: any, patchFlag?: number, dynamicProps?: string[], shapeFlag?: number): VNode<RendererNode, RendererElement, {
+    [key: string]: any;
+}>;
+/**
+ * Create a block root vnode. Takes the same exact arguments as `createVNode`.
+ * A block root keeps track of dynamic nodes within the block in the
+ * `dynamicChildren` array.
+ *
+ * @private
+ */
+export declare function createBlock(type: VNodeTypes | ClassComponent, props?: Record<string, any> | null, children?: any, patchFlag?: number, dynamicProps?: string[]): VNode;
+export declare function isVNode(value: any): value is VNode;
+declare let vnodeArgsTransformer: ((args: Parameters<typeof _createVNode>, instance: ComponentInternalInstance | null) => Parameters<typeof _createVNode>) | undefined;
+/**
+ * Internal API for registering an arguments transform for createVNode
+ * used for creating stubs in the test-utils
+ * It is *internal* but needs to be exposed for test-utils to pick up proper
+ * typings
+ */
+export declare function transformVNodeArgs(transformer?: typeof vnodeArgsTransformer): void;
+export declare function createBaseVNode(type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT, props?: (Data & VNodeProps) | null, children?: unknown, patchFlag?: number, dynamicProps?: string[] | null, shapeFlag?: number, isBlockNode?: boolean, needFullChildrenNormalization?: boolean): VNode<RendererNode, RendererElement, {
+    [key: string]: any;
+}>;
+
+export declare const createVNode: typeof _createVNode;
+declare function _createVNode(type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT, props?: (Data & VNodeProps) | null, children?: unknown, patchFlag?: number, dynamicProps?: string[] | null, isBlockNode?: boolean): VNode;
+export declare function guardReactiveProps(props: (Data & VNodeProps) | null): (Data & VNodeProps) | null;
+export declare function cloneVNode<T, U>(vnode: VNode<T, U>, extraProps?: (Data & VNodeProps) | null, mergeRef?: boolean): VNode<T, U>;
+/**
+ * @private
+ */
+export declare function createTextVNode(text?: string, flag?: number): VNode;
+/**
+ * @private
+ */
+export declare function createStaticVNode(content: string, numberOfNodes: number): VNode;
+/**
+ * @private
+ */
+export declare function createCommentVNode(text?: string, asBlock?: boolean): VNode;
+export declare function mergeProps(...args: (Data & VNodeProps)[]): Data;
+
+type Data = Record<string, unknown>;
+/**
+ * For extending allowed non-declared props on components in TSX
+ */
+export interface ComponentCustomProps {
+}
+/**
+ * Default allowed non-declared props on component in TSX
+ */
+export interface AllowedComponentProps {
+    class?: unknown;
+    style?: unknown;
+}
+interface ComponentInternalOptions {
+    /**
+     * Compat build only, for bailing out of certain compatibility behavior
+     */
+    __isBuiltIn?: boolean;
+    /**
+     * This one should be exposed so that devtools can make use of it
+     */
+    __file?: string;
+    /**
+     * name inferred from filename
+     */
+    __name?: string;
+}
+export interface FunctionalComponent<P = {}, E extends EmitsOptions = {}, S extends Record<string, any> = any> extends ComponentInternalOptions {
+    (props: P, ctx: Omit<SetupContext<E, IfAny<S, {}, SlotsType<S>>>, 'expose'>): any;
+    props?: ComponentPropsOptions<P>;
+    emits?: E | (keyof E)[];
+    slots?: IfAny<S, Slots, SlotsType<S>>;
+    inheritAttrs?: boolean;
+    displayName?: string;
+    compatConfig?: CompatConfig;
+}
+interface ClassComponent {
+    new (...args: any[]): ComponentPublicInstance<any, any, any, any, any>;
+    __vccOpts: ComponentOptions;
+}
+/**
+ * Concrete component type matches its actual value: it's either an options
+ * object, or a function. Use this where the code expects to work with actual
+ * values, e.g. checking if its a function or not. This is mostly for internal
+ * implementation code.
+ */
+export type ConcreteComponent<Props = {}, RawBindings = any, D = any, C extends ComputedOptions = ComputedOptions, M extends MethodOptions = MethodOptions> = ComponentOptions<Props, RawBindings, D, C, M> | FunctionalComponent<Props, any>;
+/**
+ * A type used in public APIs where a component type is expected.
+ * The constructor type is an artificial type returned by defineComponent().
+ */
+export type Component<Props = any, RawBindings = any, D = any, C extends ComputedOptions = ComputedOptions, M extends MethodOptions = MethodOptions> = ConcreteComponent<Props, RawBindings, D, C, M> | ComponentPublicInstanceConstructor<Props>;
+
+export type SetupContext<E = EmitsOptions, S extends SlotsType = {}> = E extends any ? {
+    attrs: Data;
+    slots: UnwrapSlotsType<S>;
+    emit: EmitFn<E>;
+    expose: (exposed?: Record<string, any>) => void;
+} : never;
+/**
+ * We expose a subset of properties on the internal instance as they are
+ * useful for advanced external libraries and tools.
+ */
+export interface ComponentInternalInstance {
+    uid: number;
+    type: ConcreteComponent;
+    parent: ComponentInternalInstance | null;
+    root: ComponentInternalInstance;
+    appContext: AppContext;
+    /**
+     * Vnode representing this component in its parent's vdom tree
+     */
+    vnode: VNode;
+    /**
+     * Root vnode of this component's own vdom tree
+     */
+    subTree: VNode;
+    /**
+     * Render effect instance
+     */
+    effect: ReactiveEffect;
+    /**
+     * Bound effect runner to be passed to schedulers
+     */
+    update: SchedulerJob;
+    proxy: ComponentPublicInstance | null;
+    exposed: Record<string, any> | null;
+    exposeProxy: Record<string, any> | null;
+    data: Data;
+    props: Data;
+    attrs: Data;
+    slots: InternalSlots;
+    refs: Data;
+    emit: EmitFn;
+    attrsProxy: Data | null;
+    slotsProxy: Slots | null;
+    isMounted: boolean;
+    isUnmounted: boolean;
+    isDeactivated: boolean;
+}
+export declare const getCurrentInstance: () => ComponentInternalInstance | null;
+/**
+ * For runtime-dom to register the compiler.
+ * Note the exported method uses any to avoid d.ts relying on the compiler types.
+ */
+export declare function registerRuntimeCompiler(_compile: any): void;
+export declare const isRuntimeOnly: () => boolean;
+
+export type WatchEffect = (onCleanup: OnCleanup) => void;
+export type WatchSource<T = any> = Ref<T> | ComputedRef<T> | (() => T);
+export type WatchCallback<V = any, OV = any> = (value: V, oldValue: OV, onCleanup: OnCleanup) => any;
+type MapSources<T, Immediate> = {
+    [K in keyof T]: T[K] extends WatchSource<infer V> ? Immediate extends true ? V | undefined : V : T[K] extends object ? Immediate extends true ? T[K] | undefined : T[K] : never;
+};
+type OnCleanup = (cleanupFn: () => void) => void;
+export interface WatchOptionsBase extends DebuggerOptions {
+    flush?: 'pre' | 'post' | 'sync';
+}
+export interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {
+    immediate?: Immediate;
+    deep?: boolean;
+}
+export type WatchStopHandle = () => void;
+export declare function watchEffect(effect: WatchEffect, options?: WatchOptionsBase): WatchStopHandle;
+export declare function watchPostEffect(effect: WatchEffect, options?: DebuggerOptions): WatchStopHandle;
+export declare function watchSyncEffect(effect: WatchEffect, options?: DebuggerOptions): WatchStopHandle;
+type MultiWatchSources = (WatchSource<unknown> | object)[];
+export declare function watch<T extends MultiWatchSources, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): WatchStopHandle;
+export declare function watch<T extends Readonly<MultiWatchSources>, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): WatchStopHandle;
+export declare function watch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchOptions<Immediate>): WatchStopHandle;
+export declare function watch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchOptions<Immediate>): WatchStopHandle;
+
+type AsyncComponentResolveResult<T = Component> = T | {
+    default: T;
+};
+export type AsyncComponentLoader<T = any> = () => Promise<AsyncComponentResolveResult<T>>;
+export interface AsyncComponentOptions<T = any> {
+    loader: AsyncComponentLoader<T>;
+    loadingComponent?: Component;
+    errorComponent?: Component;
+    delay?: number;
+    timeout?: number;
+    suspensible?: boolean;
+    onError?: (error: Error, retry: () => void, fail: () => void, attempts: number) => any;
+}
+/*! #__NO_SIDE_EFFECTS__ */
+export declare function defineAsyncComponent<T extends Component = {
+    new (): ComponentPublicInstance;
+}>(source: AsyncComponentLoader<T> | AsyncComponentOptions<T>): T;
+
+/**
+ * Vue `<script setup>` compiler macro for declaring component props. The
+ * expected argument is the same as the component `props` option.
+ *
+ * Example runtime declaration:
+ * ```js
+ * // using Array syntax
+ * const props = defineProps(['foo', 'bar'])
+ * // using Object syntax
+ * const props = defineProps({
+ *   foo: String,
+ *   bar: {
+ *     type: Number,
+ *     required: true
+ *   }
+ * })
+ * ```
+ *
+ * Equivalent type-based declaration:
+ * ```ts
+ * // will be compiled into equivalent runtime declarations
+ * const props = defineProps<{
+ *   foo?: string
+ *   bar: number
+ * }>()
+ *
+ * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineprops-defineemits}
+ * ```
+ *
+ * This is only usable inside `<script setup>`, is compiled away in the
+ * output and should **not** be actually called at runtime.
+ */
+export declare function defineProps<PropNames extends string = string>(props: PropNames[]): Prettify<Readonly<{
+    [key in PropNames]?: any;
+}>>;
+export declare function defineProps<PP extends ComponentObjectPropsOptions = ComponentObjectPropsOptions>(props: PP): Prettify<Readonly<ExtractPropTypes<PP>>>;
+export declare function defineProps<TypeProps>(): DefineProps<LooseRequired<TypeProps>, BooleanKey<TypeProps>>;
+type DefineProps<T, BKeys extends keyof T> = Readonly<T> & {
+    readonly [K in BKeys]-?: boolean;
+};
+type BooleanKey<T, K extends keyof T = keyof T> = K extends any ? [T[K]] extends [boolean | undefined] ? K : never : never;
+/**
+ * Vue `<script setup>` compiler macro for declaring a component's emitted
+ * events. The expected argument is the same as the component `emits` option.
+ *
+ * Example runtime declaration:
+ * ```js
+ * const emit = defineEmits(['change', 'update'])
+ * ```
+ *
+ * Example type-based declaration:
+ * ```ts
+ * const emit = defineEmits<{
+ *   (event: 'change'): void
+ *   (event: 'update', id: number): void
+ * }>()
+ *
+ * emit('change')
+ * emit('update', 1)
+ * ```
+ *
+ * This is only usable inside `<script setup>`, is compiled away in the
+ * output and should **not** be actually called at runtime.
+ *
+ * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineprops-defineemits}
+ */
+export declare function defineEmits<EE extends string = string>(emitOptions: EE[]): EmitFn<EE[]>;
+export declare function defineEmits<E extends EmitsOptions = EmitsOptions>(emitOptions: E): EmitFn<E>;
+export declare function defineEmits<T extends ((...args: any[]) => any) | Record<string, any[]>>(): T extends (...args: any[]) => any ? T : ShortEmits<T>;
+type RecordToUnion<T extends Record<string, any>> = T[keyof T];
+type ShortEmits<T extends Record<string, any>> = UnionToIntersection<RecordToUnion<{
+    [K in keyof T]: (evt: K, ...args: T[K]) => void;
+}>>;
+/**
+ * Vue `<script setup>` compiler macro for declaring a component's exposed
+ * instance properties when it is accessed by a parent component via template
+ * refs.
+ *
+ * `<script setup>` components are closed by default - i.e. variables inside
+ * the `<script setup>` scope is not exposed to parent unless explicitly exposed
+ * via `defineExpose`.
+ *
+ * This is only usable inside `<script setup>`, is compiled away in the
+ * output and should **not** be actually called at runtime.
+ *
+ * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineexpose}
+ */
+export declare function defineExpose<Exposed extends Record<string, any> = Record<string, any>>(exposed?: Exposed): void;
+/**
+ * Vue `<script setup>` compiler macro for declaring a component's additional
+ * options. This should be used only for options that cannot be expressed via
+ * Composition API - e.g. `inheritAttrs`.
+ *
+ * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineoptions}
+ */
+export declare function defineOptions<RawBindings = {}, D = {}, C extends ComputedOptions = {}, M extends MethodOptions = {}, Mixin extends ComponentOptionsMixin = ComponentOptionsMixin, Extends extends ComponentOptionsMixin = ComponentOptionsMixin>(options?: ComponentOptionsWithoutProps<{}, RawBindings, D, C, M, Mixin, Extends> & {
+    emits?: undefined;
+    expose?: undefined;
+    slots?: undefined;
+}): void;
+export declare function defineSlots<S extends Record<string, any> = Record<string, any>>(): StrictUnwrapSlotsType<SlotsType<S>>;
+/**
+ * (**Experimental**) Vue `<script setup>` compiler macro for declaring a
+ * two-way binding prop that can be consumed via `v-model` from the parent
+ * component. This will declare a prop with the same name and a corresponding
+ * `update:propName` event.
+ *
+ * If the first argument is a string, it will be used as the prop name;
+ * Otherwise the prop name will default to "modelValue". In both cases, you
+ * can also pass an additional object which will be used as the prop's options.
+ *
+ * The options object can also specify an additional option, `local`. When set
+ * to `true`, the ref can be locally mutated even if the parent did not pass
+ * the matching `v-model`.
+ *
+ * @example
+ * ```ts
+ * // default model (consumed via `v-model`)
+ * const modelValue = defineModel<string>()
+ * modelValue.value = "hello"
+ *
+ * // default model with options
+ * const modelValue = defineModel<string>({ required: true })
+ *
+ * // with specified name (consumed via `v-model:count`)
+ * const count = defineModel<number>('count')
+ * count.value++
+ *
+ * // with specified name and default value
+ * const count = defineModel<number>('count', { default: 0 })
+ *
+ * // local mutable model, can be mutated locally
+ * // even if the parent did not pass the matching `v-model`.
+ * const count = defineModel<number>('count', { local: true, default: 0 })
+ * ```
+ */
+export declare function defineModel<T>(options: {
+    required: true;
+} & PropOptions<T> & DefineModelOptions): Ref<T>;
+export declare function defineModel<T>(options: {
+    default: any;
+} & PropOptions<T> & DefineModelOptions): Ref<T>;
+export declare function defineModel<T>(options?: PropOptions<T> & DefineModelOptions): Ref<T | undefined>;
+export declare function defineModel<T>(name: string, options: {
+    required: true;
+} & PropOptions<T> & DefineModelOptions): Ref<T>;
+export declare function defineModel<T>(name: string, options: {
+    default: any;
+} & PropOptions<T> & DefineModelOptions): Ref<T>;
+export declare function defineModel<T>(name: string, options?: PropOptions<T> & DefineModelOptions): Ref<T | undefined>;
+interface DefineModelOptions {
+    local?: boolean;
+}
+type NotUndefined<T> = T extends undefined ? never : T;
+type InferDefaults<T> = {
+    [K in keyof T]?: InferDefault<T, T[K]>;
+};
+type NativeType = null | number | string | boolean | symbol | Function;
+type InferDefault<P, T> = ((props: P) => T & {}) | (T extends NativeType ? T : never);
+type PropsWithDefaults<T, Defaults extends InferDefaults<T>, BKeys extends keyof T> = Readonly<Omit<T, keyof Defaults>> & {
+    readonly [K in keyof Defaults]-?: K extends keyof T ? Defaults[K] extends undefined ? T[K] : NotUndefined<T[K]> : never;
+} & {
+    readonly [K in BKeys]-?: K extends keyof Defaults ? Defaults[K] extends undefined ? boolean | undefined : boolean : boolean;
+};
+/**
+ * Vue `<script setup>` compiler macro for providing props default values when
+ * using type-based `defineProps` declaration.
+ *
+ * Example usage:
+ * ```ts
+ * withDefaults(defineProps<{
+ *   size?: number
+ *   labels?: string[]
+ * }>(), {
+ *   size: 3,
+ *   labels: () => ['default label']
+ * })
+ * ```
+ *
+ * This is only usable inside `<script setup>`, is compiled away in the output
+ * and should **not** be actually called at runtime.
+ *
+ * @see {@link https://vuejs.org/guide/typescript/composition-api.html#typing-component-props}
+ */
+export declare function withDefaults<T, BKeys extends keyof T, Defaults extends InferDefaults<T>>(props: DefineProps<T, BKeys>, defaults: Defaults): PropsWithDefaults<T, Defaults, BKeys>;
+export declare function useSlots(): SetupContext['slots'];
+export declare function useAttrs(): SetupContext['attrs'];
+export declare function useModel<T extends Record<string, any>, K extends keyof T>(props: T, name: K, options?: {
+    local?: boolean;
+}): Ref<T[K]>;
+
+type RawProps = VNodeProps & {
+    __v_isVNode?: never;
+    [Symbol.iterator]?: never;
+} & Record<string, any>;
+type RawChildren = string | number | boolean | VNode | VNodeArrayChildren | (() => any);
+interface Constructor<P = any> {
+    __isFragment?: never;
+    __isTeleport?: never;
+    __isSuspense?: never;
+    new (...args: any[]): {
+        $props: P;
+    };
+}
+export declare function h(type: string, children?: RawChildren): VNode;
+export declare function h(type: string, props?: RawProps | null, children?: RawChildren | RawSlots): VNode;
+export declare function h(type: typeof Text | typeof Comment, children?: string | number | boolean): VNode;
+export declare function h(type: typeof Text | typeof Comment, props?: null, children?: string | number | boolean): VNode;
+export declare function h(type: typeof Fragment, children?: VNodeArrayChildren): VNode;
+export declare function h(type: typeof Fragment, props?: RawProps | null, children?: VNodeArrayChildren): VNode;
+export declare function h(type: typeof Teleport, props: RawProps & TeleportProps, children: RawChildren | RawSlots): VNode;
+export declare function h(type: typeof Suspense, children?: RawChildren): VNode;
+export declare function h(type: typeof Suspense, props?: (RawProps & SuspenseProps) | null, children?: RawChildren | RawSlots): VNode;
+export declare function h<P, E extends EmitsOptions = {}, S extends Record<string, any> = {}>(type: FunctionalComponent<P, E, S>, props?: (RawProps & P) | ({} extends P ? null : never), children?: RawChildren | RawSlots): VNode;
+export declare function h(type: Component, children?: RawChildren): VNode;
+export declare function h<P>(type: ConcreteComponent | string, children?: RawChildren): VNode;
+export declare function h<P>(type: ConcreteComponent<P> | string, props?: (RawProps & P) | ({} extends P ? null : never), children?: RawChildren): VNode;
+export declare function h<P>(type: Component<P>, props?: (RawProps & P) | null, children?: RawChildren | RawSlots): VNode;
+export declare function h<P>(type: ComponentOptions<P>, props?: (RawProps & P) | ({} extends P ? null : never), children?: RawChildren | RawSlots): VNode;
+export declare function h(type: Constructor, children?: RawChildren): VNode;
+export declare function h<P>(type: Constructor<P>, props?: (RawProps & P) | ({} extends P ? null : never), children?: RawChildren | RawSlots): VNode;
+export declare function h(type: DefineComponent, children?: RawChildren): VNode;
+export declare function h<P>(type: DefineComponent<P>, props?: (RawProps & P) | ({} extends P ? null : never), children?: RawChildren | RawSlots): VNode;
+export declare function h(type: string | Component, children?: RawChildren): VNode;
+export declare function h<P>(type: string | Component<P>, props?: (RawProps & P) | ({} extends P ? null : never), children?: RawChildren | RawSlots): VNode;
+
+export declare const ssrContextKey: unique symbol;
+export declare const useSSRContext: <T = Record<string, any>>() => T | undefined;
+
+export declare function warn(msg: string, ...args: any[]): void;
+
+export declare const enum ErrorCodes {
+    SETUP_FUNCTION = 0,
+    RENDER_FUNCTION = 1,
+    WATCH_GETTER = 2,
+    WATCH_CALLBACK = 3,
+    WATCH_CLEANUP = 4,
+    NATIVE_EVENT_HANDLER = 5,
+    COMPONENT_EVENT_HANDLER = 6,
+    VNODE_HOOK = 7,
+    DIRECTIVE_HOOK = 8,
+    TRANSITION_HOOK = 9,
+    APP_ERROR_HANDLER = 10,
+    APP_WARN_HANDLER = 11,
+    FUNCTION_REF = 12,
+    ASYNC_COMPONENT_LOADER = 13,
+    SCHEDULER = 14
+}
+type ErrorTypes = LifecycleHooks | ErrorCodes;
+export declare function callWithErrorHandling(fn: Function, instance: ComponentInternalInstance | null, type: ErrorTypes, args?: unknown[]): any;
+export declare function callWithAsyncErrorHandling(fn: Function | Function[], instance: ComponentInternalInstance | null, type: ErrorTypes, args?: unknown[]): any[];
+export declare function handleError(err: unknown, instance: ComponentInternalInstance | null, type: ErrorTypes, throwInDev?: boolean): void;
+
+export declare function initCustomFormatter(): void;
+
+interface AppRecord {
+    id: number;
+    app: App;
+    version: string;
+    types: Record<string, string | Symbol>;
+}
+interface DevtoolsHook {
+    enabled?: boolean;
+    emit: (event: string, ...payload: any[]) => void;
+    on: (event: string, handler: Function) => void;
+    once: (event: string, handler: Function) => void;
+    off: (event: string, handler: Function) => void;
+    appRecords: AppRecord[];
+    /**
+     * Added at https://github.com/vuejs/devtools/commit/f2ad51eea789006ab66942e5a27c0f0986a257f9
+     * Returns whether the arg was buffered or not
+     */
+    cleanupBuffer?: (matchArg: unknown) => boolean;
+}
+export declare let devtools: DevtoolsHook;
+export declare function setDevtoolsHook(hook: DevtoolsHook, target: any): void;
+
+type HMRComponent = ComponentOptions | ClassComponent;
+export interface HMRRuntime {
+    createRecord: typeof createRecord;
+    rerender: typeof rerender;
+    reload: typeof reload;
+}
+declare function createRecord(id: string, initialDef: HMRComponent): boolean;
+declare function rerender(id: string, newRender?: Function): void;
+declare function reload(id: string, newComp: HMRComponent): void;
+
+/**
+ * Set scope id when creating hoisted vnodes.
+ * @private compiler helper
+ */
+export declare function pushScopeId(id: string | null): void;
+/**
+ * Technically we no longer need this after 3.0.8 but we need to keep the same
+ * API for backwards compat w/ code generated by compilers.
+ * @private
+ */
+export declare function popScopeId(): void;
+/**
+ * Only for backwards compat
+ * @private
+ */
+export declare const withScopeId: (_id: string) => typeof withCtx;
+/**
+ * Wrap a slot function to memoize current rendering instance
+ * @private compiler helper
+ */
+export declare function withCtx(fn: Function, ctx?: ComponentInternalInstance | null, isNonScopedSlot?: boolean): Function;
+
+/**
+ * v-for string
+ * @private
+ */
+export declare function renderList(source: string, renderItem: (value: string, index: number) => VNodeChild): VNodeChild[];
+/**
+ * v-for number
+ */
+export declare function renderList(source: number, renderItem: (value: number, index: number) => VNodeChild): VNodeChild[];
+/**
+ * v-for array
+ */
+export declare function renderList<T>(source: T[], renderItem: (value: T, index: number) => VNodeChild): VNodeChild[];
+/**
+ * v-for iterable
+ */
+export declare function renderList<T>(source: Iterable<T>, renderItem: (value: T, index: number) => VNodeChild): VNodeChild[];
+/**
+ * v-for object
+ */
+export declare function renderList<T>(source: T, renderItem: <K extends keyof T>(value: T[K], key: K, index: number) => VNodeChild): VNodeChild[];
+
+/**
+ * For prefixing keys in v-on="obj" with "on"
+ * @private
+ */
+export declare function toHandlers(obj: Record<string, any>, preserveCaseIfNecessary?: boolean): Record<string, any>;
+
+/**
+ * Compiler runtime helper for rendering `<slot/>`
+ * @private
+ */
+export declare function renderSlot(slots: Slots, name: string, props?: Data, fallback?: () => VNodeArrayChildren, noSlotted?: boolean): VNode;
+
+type SSRSlot = (...args: any[]) => VNode[] | undefined;
+interface CompiledSlotDescriptor {
+    name: string;
+    fn: SSRSlot;
+    key?: string;
+}
+/**
+ * Compiler runtime helper for creating dynamic slots object
+ * @private
+ */
+export declare function createSlots(slots: Record<string, SSRSlot>, dynamicSlots: (CompiledSlotDescriptor | CompiledSlotDescriptor[] | undefined)[]): Record<string, SSRSlot>;
+
+export declare function withMemo(memo: any[], render: () => VNode<any, any>, cache: any[], index: number): VNode<any, any, {
+    [key: string]: any;
+}>;
+export declare function isMemoSame(cached: VNode, memo: any[]): boolean;
+
+export type LegacyConfig = {
+    /**
+     * @deprecated `config.silent` option has been removed
+     */
+    silent?: boolean;
+    /**
+     * @deprecated use __VUE_PROD_DEVTOOLS__ compile-time feature flag instead
+     * https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags
+     */
+    devtools?: boolean;
+    /**
+     * @deprecated use `config.isCustomElement` instead
+     * https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-ignoredelements-is-now-config-iscustomelement
+     */
+    ignoredElements?: (string | RegExp)[];
+    /**
+     * @deprecated
+     * https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html
+     */
+    keyCodes?: Record<string, number | number[]>;
+    /**
+     * @deprecated
+     * https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-productiontip-removed
+     */
+    productionTip?: boolean;
+};
+
+type LegacyPublicInstance = ComponentPublicInstance & LegacyPublicProperties;
+interface LegacyPublicProperties {
+    $set(target: object, key: string, value: any): void;
+    $delete(target: object, key: string): void;
+    $mount(el?: string | Element): this;
+    $destroy(): void;
+    $scopedSlots: Slots;
+    $on(event: string | string[], fn: Function): this;
+    $once(event: string, fn: Function): this;
+    $off(event?: string | string[], fn?: Function): this;
+    $children: LegacyPublicProperties[];
+    $listeners: Record<string, Function | Function[]>;
+}
+
+/**
+ * @deprecated the default `Vue` export has been removed in Vue 3. The type for
+ * the default export is provided only for migration purposes. Please use
+ * named imports instead - e.g. `import { createApp } from 'vue'`.
+ */
+export type CompatVue = Pick<App, 'version' | 'component' | 'directive'> & {
+    configureCompat: typeof configureCompat;
+    new (options?: ComponentOptions): LegacyPublicInstance;
+    version: string;
+    config: AppConfig & LegacyConfig;
+    nextTick: typeof nextTick;
+    use(plugin: Plugin, ...options: any[]): CompatVue;
+    mixin(mixin: ComponentOptions): CompatVue;
+    component(name: string): Component | undefined;
+    component(name: string, component: Component): CompatVue;
+    directive(name: string): Directive | undefined;
+    directive(name: string, directive: Directive): CompatVue;
+    compile(template: string): RenderFunction;
+    /**
+     * @deprecated Vue 3 no longer supports extending constructors.
+     */
+    extend: (options?: ComponentOptions) => CompatVue;
+    /**
+     * @deprecated Vue 3 no longer needs set() for adding new properties.
+     */
+    set(target: any, key: string | number | symbol, value: any): void;
+    /**
+     * @deprecated Vue 3 no longer needs delete() for property deletions.
+     */
+    delete(target: any, key: string | number | symbol): void;
+    /**
+     * @deprecated use `reactive` instead.
+     */
+    observable: typeof reactive;
+    /**
+     * @deprecated filters have been removed from Vue 3.
+     */
+    filter(name: string, arg?: any): null;
+};
+
+export declare const version: string;
+
+declare module '@vue/reactivity' {
+    interface RefUnwrapBailTypes {
+        runtimeCoreBailTypes: VNode | {
+            $: ComponentInternalInstance;
+        };
+    }
+}
+
+export { createBaseVNode as createElementVNode,  };
+// Note: this file is auto concatenated to the end of the bundled d.ts during
+// build.
+type _defineProps = typeof defineProps
+type _defineEmits = typeof defineEmits
+type _defineExpose = typeof defineExpose
+type _defineOptions = typeof defineOptions
+type _defineSlots = typeof defineSlots
+type _defineModel = typeof defineModel
+type _withDefaults = typeof withDefaults
+
+declare global {
+  const defineProps: _defineProps
+  const defineEmits: _defineEmits
+  const defineExpose: _defineExpose
+  const defineOptions: _defineOptions
+  const defineSlots: _defineSlots
+  const defineModel: _defineModel
+  const withDefaults: _withDefaults
+}
diff --git a/types/vue/shared.d.ts b/types/vue/shared.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5e4991b5bc4e8cc13d9f52273c4aca466488b0a1
--- /dev/null
+++ b/types/vue/shared.d.ts
@@ -0,0 +1,314 @@
+/**
+ * Make a map and return a function for checking if a key
+ * is in that map.
+ * IMPORTANT: all calls of this function must be prefixed with
+ * \/\*#\_\_PURE\_\_\*\/
+ * So that rollup can tree-shake them if necessary.
+ */
+export declare function makeMap(str: string, expectsLowerCase?: boolean): (key: string) => boolean;
+
+export declare const EMPTY_OBJ: {
+    readonly [key: string]: any;
+};
+export declare const EMPTY_ARR: readonly never[];
+export declare const NOOP: () => void;
+/**
+ * Always return false.
+ */
+export declare const NO: () => boolean;
+export declare const isOn: (key: string) => boolean;
+export declare const isModelListener: (key: string) => boolean;
+export declare const extend: {
+    <T extends {}, U>(target: T, source: U): T & U;
+    <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V;
+    <T_2 extends {}, U_2, V_1, W>(target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W;
+    (target: object, ...sources: any[]): any;
+};
+export declare const remove: <T>(arr: T[], el: T) => void;
+export declare const hasOwn: (val: object, key: string | symbol) => key is never;
+export declare const isArray: (arg: any) => arg is any[];
+export declare const isMap: (val: unknown) => val is Map<any, any>;
+export declare const isSet: (val: unknown) => val is Set<any>;
+export declare const isDate: (val: unknown) => val is Date;
+export declare const isRegExp: (val: unknown) => val is RegExp;
+export declare const isFunction: (val: unknown) => val is Function;
+export declare const isString: (val: unknown) => val is string;
+export declare const isSymbol: (val: unknown) => val is symbol;
+export declare const isObject: (val: unknown) => val is Record<any, any>;
+export declare const isPromise: <T = any>(val: unknown) => val is Promise<T>;
+export declare const objectToString: () => string;
+export declare const toTypeString: (value: unknown) => string;
+export declare const toRawType: (value: unknown) => string;
+export declare const isPlainObject: (val: unknown) => val is object;
+export declare const isIntegerKey: (key: unknown) => boolean;
+export declare const isReservedProp: (key: string) => boolean;
+export declare const isBuiltInDirective: (key: string) => boolean;
+/**
+ * @private
+ */
+export declare const camelize: (str: string) => string;
+/**
+ * @private
+ */
+export declare const hyphenate: (str: string) => string;
+/**
+ * @private
+ */
+export declare const capitalize: <T extends string>(str: T) => Capitalize<T>;
+/**
+ * @private
+ */
+export declare const toHandlerKey: <T extends string>(str: T) => T extends "" ? "" : `on${Capitalize<T>}`;
+export declare const hasChanged: (value: any, oldValue: any) => boolean;
+export declare const invokeArrayFns: (fns: Function[], arg?: any) => void;
+export declare const def: (obj: object, key: string | symbol, value: any) => void;
+/**
+ * "123-foo" will be parsed to 123
+ * This is used for the .number modifier in v-model
+ */
+export declare const looseToNumber: (val: any) => any;
+/**
+ * Only concerns number-like strings
+ * "123-foo" will be returned as-is
+ */
+export declare const toNumber: (val: any) => any;
+export declare const getGlobalThis: () => any;
+export declare function genPropsAccessExp(name: string): string;
+
+/**
+ * Patch flags are optimization hints generated by the compiler.
+ * when a block with dynamicChildren is encountered during diff, the algorithm
+ * enters "optimized mode". In this mode, we know that the vdom is produced by
+ * a render function generated by the compiler, so the algorithm only needs to
+ * handle updates explicitly marked by these patch flags.
+ *
+ * Patch flags can be combined using the | bitwise operator and can be checked
+ * using the & operator, e.g.
+ *
+ * ```js
+ * const flag = TEXT | CLASS
+ * if (flag & TEXT) { ... }
+ * ```
+ *
+ * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the
+ * flags are handled during diff.
+ */
+export declare const enum PatchFlags {
+    /**
+     * Indicates an element with dynamic textContent (children fast path)
+     */
+    TEXT = 1,
+    /**
+     * Indicates an element with dynamic class binding.
+     */
+    CLASS = 2,
+    /**
+     * Indicates an element with dynamic style
+     * The compiler pre-compiles static string styles into static objects
+     * + detects and hoists inline static objects
+     * e.g. `style="color: red"` and `:style="{ color: 'red' }"` both get hoisted
+     * as:
+     * ```js
+     * const style = { color: 'red' }
+     * render() { return e('div', { style }) }
+     * ```
+     */
+    STYLE = 4,
+    /**
+     * Indicates an element that has non-class/style dynamic props.
+     * Can also be on a component that has any dynamic props (includes
+     * class/style). when this flag is present, the vnode also has a dynamicProps
+     * array that contains the keys of the props that may change so the runtime
+     * can diff them faster (without having to worry about removed props)
+     */
+    PROPS = 8,
+    /**
+     * Indicates an element with props with dynamic keys. When keys change, a full
+     * diff is always needed to remove the old key. This flag is mutually
+     * exclusive with CLASS, STYLE and PROPS.
+     */
+    FULL_PROPS = 16,
+    /**
+     * Indicates an element that requires props hydration
+     * (but not necessarily patching)
+     * e.g. event listeners & v-bind with prop modifier
+     */
+    NEED_HYDRATION = 32,
+    /**
+     * Indicates a fragment whose children order doesn't change.
+     */
+    STABLE_FRAGMENT = 64,
+    /**
+     * Indicates a fragment with keyed or partially keyed children
+     */
+    KEYED_FRAGMENT = 128,
+    /**
+     * Indicates a fragment with unkeyed children.
+     */
+    UNKEYED_FRAGMENT = 256,
+    /**
+     * Indicates an element that only needs non-props patching, e.g. ref or
+     * directives (onVnodeXXX hooks). since every patched vnode checks for refs
+     * and onVnodeXXX hooks, it simply marks the vnode so that a parent block
+     * will track it.
+     */
+    NEED_PATCH = 512,
+    /**
+     * Indicates a component with dynamic slots (e.g. slot that references a v-for
+     * iterated value, or dynamic slot names).
+     * Components with this flag are always force updated.
+     */
+    DYNAMIC_SLOTS = 1024,
+    /**
+     * Indicates a fragment that was created only because the user has placed
+     * comments at the root level of a template. This is a dev-only flag since
+     * comments are stripped in production.
+     */
+    DEV_ROOT_FRAGMENT = 2048,
+    /**
+     * SPECIAL FLAGS -------------------------------------------------------------
+     * Special flags are negative integers. They are never matched against using
+     * bitwise operators (bitwise matching should only happen in branches where
+     * patchFlag > 0), and are mutually exclusive. When checking for a special
+     * flag, simply check patchFlag === FLAG.
+     */
+    /**
+     * Indicates a hoisted static vnode. This is a hint for hydration to skip
+     * the entire sub tree since static content never needs to be updated.
+     */
+    HOISTED = -1,
+    /**
+     * A special flag that indicates that the diffing algorithm should bail out
+     * of optimized mode. For example, on block fragments created by renderSlot()
+     * when encountering non-compiler generated slots (i.e. manually written
+     * render functions, which should always be fully diffed)
+     * OR manually cloneVNodes
+     */
+    BAIL = -2
+}
+/**
+ * dev only flag -> name mapping
+ */
+export declare const PatchFlagNames: Record<PatchFlags, string>;
+
+export declare const enum ShapeFlags {
+    ELEMENT = 1,
+    FUNCTIONAL_COMPONENT = 2,
+    STATEFUL_COMPONENT = 4,
+    TEXT_CHILDREN = 8,
+    ARRAY_CHILDREN = 16,
+    SLOTS_CHILDREN = 32,
+    TELEPORT = 64,
+    SUSPENSE = 128,
+    COMPONENT_SHOULD_KEEP_ALIVE = 256,
+    COMPONENT_KEPT_ALIVE = 512,
+    COMPONENT = 6
+}
+
+export declare const enum SlotFlags {
+    /**
+     * Stable slots that only reference slot props or context state. The slot
+     * can fully capture its own dependencies so when passed down the parent won't
+     * need to force the child to update.
+     */
+    STABLE = 1,
+    /**
+     * Slots that reference scope variables (v-for or an outer slot prop), or
+     * has conditional structure (v-if, v-for). The parent will need to force
+     * the child to update because the slot does not fully capture its dependencies.
+     */
+    DYNAMIC = 2,
+    /**
+     * `<slot/>` being forwarded into a child component. Whether the parent needs
+     * to update the child is dependent on what kind of slots the parent itself
+     * received. This has to be refined at runtime, when the child's vnode
+     * is being created (in `normalizeChildren`)
+     */
+    FORWARDED = 3
+}
+/**
+ * Dev only
+ */
+export declare const slotFlagsText: {
+    1: string;
+    2: string;
+    3: string;
+};
+
+export declare const isGloballyAllowed: (key: string) => boolean;
+/** @deprecated use `isGloballyAllowed` instead */
+export declare const isGloballyWhitelisted: (key: string) => boolean;
+
+export declare function generateCodeFrame(source: string, start?: number, end?: number): string;
+
+export type NormalizedStyle = Record<string, string | number>;
+export declare function normalizeStyle(value: unknown): NormalizedStyle | string | undefined;
+export declare function parseStringStyle(cssText: string): NormalizedStyle;
+export declare function stringifyStyle(styles: NormalizedStyle | string | undefined): string;
+export declare function normalizeClass(value: unknown): string;
+export declare function normalizeProps(props: Record<string, any> | null): Record<string, any> | null;
+
+/**
+ * Compiler only.
+ * Do NOT use in runtime code paths unless behind `__DEV__` flag.
+ */
+export declare const isHTMLTag: (key: string) => boolean;
+/**
+ * Compiler only.
+ * Do NOT use in runtime code paths unless behind `__DEV__` flag.
+ */
+export declare const isSVGTag: (key: string) => boolean;
+/**
+ * Compiler only.
+ * Do NOT use in runtime code paths unless behind `__DEV__` flag.
+ */
+export declare const isVoidTag: (key: string) => boolean;
+
+export declare const isSpecialBooleanAttr: (key: string) => boolean;
+/**
+ * The full list is needed during SSR to produce the correct initial markup.
+ */
+export declare const isBooleanAttr: (key: string) => boolean;
+/**
+ * Boolean attributes should be included if the value is truthy or ''.
+ * e.g. `<select multiple>` compiles to `{ multiple: '' }`
+ */
+export declare function includeBooleanAttr(value: unknown): boolean;
+export declare function isSSRSafeAttrName(name: string): boolean;
+export declare const propsToAttrMap: Record<string, string | undefined>;
+/**
+ * Known attributes, this is used for stringification of runtime static nodes
+ * so that we don't stringify bindings that cannot be set from HTML.
+ * Don't also forget to allow `data-*` and `aria-*`!
+ * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
+ */
+export declare const isKnownHtmlAttr: (key: string) => boolean;
+/**
+ * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
+ */
+export declare const isKnownSvgAttr: (key: string) => boolean;
+
+export declare function escapeHtml(string: unknown): string;
+export declare function escapeHtmlComment(src: string): string;
+
+export declare function looseEqual(a: any, b: any): boolean;
+export declare function looseIndexOf(arr: any[], val: any): number;
+
+/**
+ * For converting {{ interpolation }} values to displayed strings.
+ * @private
+ */
+export declare const toDisplayString: (val: unknown) => string;
+
+export type Prettify<T> = {
+    [K in keyof T]: T[K];
+} & {};
+export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
+export type LooseRequired<T> = {
+    [P in keyof (T & Required<T>)]: T[P];
+};
+export type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;
+export type Awaited<T> = T extends null | undefined ? T : T extends object & {
+    then(onfulfilled: infer F, ...args: infer _): any;
+} ? F extends (value: infer V, ...args: infer _) => any ? Awaited<V> : never : T;
+
